<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[System.Web.Helpers.Json.Decode]]></title>
    <url>%2F2019%2F09%2F23%2FSystem-Web-Helpers-Json-Decode%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 1234567891011121314151617181920212223242526Route("contents")] [HttpGet] public DataResponse&lt;dynamic&gt; contents([FromUri]PositionSearchViewModel search) &#123; var searchDTO = search.Map&lt;PositionSearchViewModel, PositionSearchDTO&gt;(Constant.MapType.LowerToPascal); var list = Business.Logic&lt;ApiPositionLogic&gt;().GetPosition(searchDTO).Map&lt;PositionDTO, PositionViewModel&gt;(Constant.MapType.PascalToLower); var model = "&#123;"; foreach (var item in list) &#123; if (model == "&#123;") model += "\"" + item.position_key + "\":" + System.Web.Helpers.Json.Encode(item); else model += ",\"" + item.position_key + "\":" + System.Web.Helpers.Json.Encode(item); &#125; model += "&#125;"; return new DataResponse&lt;dynamic&gt; &#123; success = true, code = ResponseCode.Ok.code, message = ResponseCode.Ok.message, data = System.Web.Helpers.Json.Decode(model) &#125;; &#125; 返回的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; "code": 10000, "message": "success", "success": true, "data": &#123; "product": &#123; "position_id": 15, "page_key": "product", "position_key": "product", "small_image_path": "", "big_image_path": "", "oss_small_image_path": "", "oss_big_image_path": "", "image_paths": "", "oss_image_paths": "", "tags": "", "title": "", "sub_title": "", "content": "", "date_from": "", "date_to": "", "address": "", "latitude": "", "longitude": "", "description": "" &#125;, "save": &#123; "position_id": 13, "page_key": "product", "position_key": "save", "small_image_path": "", "big_image_path": "", "oss_small_image_path": "", "oss_big_image_path": "", "image_paths": "/upload/official/image/201804/26/6af5aad0-242a-456d-94dc-5696899b90e4.jpg,/upload/official/image/201804/26/081ebd01-a41f-49f1-b6fe-bec82b27ffd9.jpg", "oss_image_paths": "http://cdn.oss.itplus.net.cn//upload/official/image/201804/26/6af5aad0-242a-456d-94dc-5696899b90e4.jpg,http://cdn.oss.itplus.net.cn//upload/official/image/201804/26/081ebd01-a41f-49f1-b6fe-bec82b27ffd9.jpg", "tags": "", "title": "", "sub_title": "", "content": "", "date_from": "", "date_to": "", "address": "", "latitude": "", "longitude": "", "description": "" &#125;, ...... ...... &#125;&#125; 123456789101112131415[Route("list")] [HttpGet] public DataResponse&lt;List&lt;PositionViewModel&gt;&gt; list([FromUri]PositionSearchViewModel search) &#123; var searchDTO = search.Map&lt;PositionSearchViewModel, PositionSearchDTO&gt;(Constant.MapType.LowerToPascal); var model = Business.Logic&lt;ApiPositionLogic&gt;().GetPosition(searchDTO); return new DataResponse&lt;List&lt;PositionViewModel&gt;&gt; &#123; success = true, code = ResponseCode.Ok.code, message = ResponseCode.Ok.message, data = model.Map&lt;PositionDTO, PositionViewModel&gt;(Constant.MapType.PascalToLower) &#125;; &#125; 返回的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 "code": 10000, "message": "success", "success": true, "data": [ &#123; "position_id": 15, "page_key": "product", "position_key": "product", "small_image_path": "", "big_image_path": "", "oss_small_image_path": "", "oss_big_image_path": "", "image_paths": "", "oss_image_paths": "", "tags": "", "title": "", "sub_title": "", "content": "", "date_from": "", "date_to": "", "address": "", "latitude": "", "longitude": "", "description": "" &#125;, &#123; "position_id": 13, "page_key": "product", "position_key": "save", "small_image_path": "", "big_image_path": "", "oss_small_image_path": "", "oss_big_image_path": "", "image_paths": "/upload/official/image/201804/26/6af5aad0-242a-456d-94dc-5696899b90e4.jpg,/upload/official/image/201804/26/081ebd01-a41f-49f1-b6fe-bec82b27ffd9.jpg", "oss_image_paths": "http://cdn.oss.itplus.net.cn//upload/official/image/201804/26/6af5aad0-242a-456d-94dc-5696899b90e4.jpg,http://cdn.oss.itplus.net.cn//upload/official/image/201804/26/081ebd01-a41f-49f1-b6fe-bec82b27ffd9.jpg", "tags": "", "title": "", "sub_title": "", "content": "", "date_from": "", "date_to": "", "address": "", "latitude": "", "longitude": "", "description": "" &#125;, ...... ...... &#125;&#125; 序列化和反序列化：转载：https://blog.csdn.net/u013870094/article/details/82765907 参考文章：System.Web.Helpers.Json 与 Newtonsoft.Json 的性能对比转载：https://www.cnblogs.com/dahuiyang/p/10965920.html#top]]></content>
  </entry>
  <entry>
    <title><![CDATA[C#框架中我注意的方法]]></title>
    <url>%2F2019%2F09%2F20%2FC-%E6%A1%86%E6%9E%B6%E4%B8%AD%E6%88%91%E6%B3%A8%E6%84%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 注：输入地址，自动获取当前地址的位置信息 _BusinessAreaAdd.cshtml(某后台的某一功能的添加页) 123456789&lt;div style="margin-top:10px;"&gt; @IPHtml.Form.BeginForm(new FormAttr &#123; Id = "frmAdd", Action = "/businessarea/addbusinessarea" &#125;) ...... //就是这句 @IPHtml.Form.Location(new LocationAttr &#123; Id = "Address", GeoId = "Location", Label = "地址：", PlaceHolder = "请输入地址！" , Required = "请选择地址！" &#125;) ...... @IPHtml.Form.Submit(new SubmitAttr &#123; Id = "btnSave", Text = "确定", OnSuccess = "itplus.businessArea.callback" &#125;) @IPHtml.Form.EndPartialViewForm(new FormAttr &#123; Id = "frmAdd" &#125;)&lt;/div&gt; BusinessAreaController: 12345public JsonResult AddBusinessArea(AddBusinessAreaViewModel model) &#123; var result = Business.Logic&lt;BusinessAreaLogic&gt;().AddBusinessArea(model.Map&lt;AddBusinessAreaViewModel, AddBusinessAreaDTO&gt;(), ClientId); return Json(result); &#125; AddBusinessAreaViewModel: 123456789public class AddBusinessAreaViewModel &#123; public string BusinessAreaName &#123; get; set; &#125; public string Address &#123; get; set; &#125; public string Location &#123; get; set; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C#--System.Configuration.ConfigurationManager.AppSettings[DB]的解释]]></title>
    <url>%2F2019%2F09%2F19%2FC-System-Configuration-ConfigurationManager-AppSettings-DB-%E7%9A%84%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 解释：System.Configuration.ConfigurationManager.AppSettings[“DB”]b/s程序从Web.config配置文件中获取key值为”DB”的Valuec/s程序从App.config配置文件中获取key值为”DB”的Value 作用: 1234&lt;AppSettings&gt;&lt;add key="config1" value="a" /&gt;&lt;add key="config2" value="b" /&gt;&lt;/AppSettings&gt; string str = System.Configuration.ConfigurationManager.AppSettings[“config1”].ToString();//str等于astring str1 = System.Configuration.ConfigurationManager.AppSettings[“config2”].ToString();//str1等于b————————————————原文链接：https://blog.csdn.net/TGBTrial/article/details/88052802]]></content>
  </entry>
  <entry>
    <title><![CDATA[C# 添加修改弹窗]]></title>
    <url>%2F2019%2F09%2F19%2FC-%E6%B7%BB%E5%8A%A0%E4%BF%AE%E6%94%B9%E5%BC%B9%E7%AA%97%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 框架结构 Index.cshtml123456789101112131415161718192021222324@model StaticPagedList&lt;EntryManagementViewModel&gt;@&#123; ViewBag.Title = "入围管理";&#125;@section containerTop&#123; &lt;div class="ip_container_top"&gt; &lt;div class="ip_title"&gt;入围管理&lt;/div&gt;&lt;a class="ip_create" onclick="itplus.entry.getEntryeAddView()"&gt;添加入围名单&lt;/a&gt; //重要的是itplus.entry.getEntryeAddView()这个方法，写在index.js中了&lt;/div&gt;&#125;@section foot&#123; &lt;script src="~/js/entrymanagement/index.js"&gt;&lt;/script&gt; &lt;script src="@Config.API.Cdn/itplus/v2/uploader.js"&gt;&lt;/script&gt;&#125;@IPHtml.Search.BeginSearch(new SearchAttr &#123; Action = "/entrymanagement/index" &#125;)@IPHtml.Search.Input(new InputAttr &#123; Id = "key_words", Label = "入围查询：" , PlaceHolder = "请输入项目名称" &#125;)@IPHtml.Search.Submit(new SearchSubmitAttr &#123; Id = "submit", UpdateTargetId = "data_list" &#125;)@IPHtml.Search.EndSearch()@IPHtml.BeginUpdateTarget(new UpdateTargetAttr &#123; Id = "data_list" &#125;)@Html.Partial("_EntryList", Model)@IPHtml.EndUpdateTarget() _EntryListItem.cshtml12345678910@model EntryManagementViewModel@IPHtml.Item(Model, r =&gt; new RowAttr &#123; Id = "id" + r.shortlist_id &#125;, r =&gt; new ColumnBodyAttr[] &#123; new ColumnBodyAttr &#123; Field=r.shortlist_id.ToString(), Width=150 &#125;, new ColumnBodyAttr &#123; Field=r.project_name, Width=150 &#125;, new ColumnBodyAttr &#123; Field=r.founder_name,Width=150 &#125;, new ColumnBodyAttr &#123; Field=r.date_created, Width=150 &#125;, new ColumnBodyAttr&#123; Field="&lt;a onclick=\"itplus.entry.getEntryEditView("+r.shortlist_id+")\"&gt;编辑&lt;/a&gt;&lt;a onclick=\"itplus.entry.deleteEntry("+r.shortlist_id+")\"&gt;删除&lt;/a&gt;" ,Width = 150&#125; //重要的是itplus.entry.getEntryEditView()这个方法，写在index.js中了 &#125;) index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152itplus.entry = new function () &#123; this.getEntryeAddView = function () &#123; itplus.ajaxPost('/entrymanagement/getentryaddview', null, function (result) &#123; layer.open(&#123; type: 1, title: "入围名单添加", skin: 'layui-layer-rim', area: ['550px', '380px'], content: result &#125;); &#125;); &#125; this.addEntryCallBack = function (result) &#123; if (typeof (result) == "string") &#123; layer.closeAll("page"); $('.empty').remove(); $('.ip_t_body').prepend(result); itplus.toast('添加成功'); &#125; else &#123; itplus.toast(result.message, 2); &#125; &#125; this.getEntryEditView = function (id) &#123; itplus.ajaxPost('/entrymanagement/getentryeditview', &#123; shortListId: id &#125;, function (result) &#123; layer.open(&#123; type: 1, title: "入围名单修改", skin: 'layui-layer-rim', area: ['550px', '380px'], content: result &#125;); &#125;); &#125; this.editEntryCallBack = function (result) &#123; if (typeof (result) == "string") &#123; $('#id' + $('#shortlist_id').val()).replaceWith(result); layer.closeAll("page"); itplus.toast('修改成功'); &#125; else &#123; itplus.toast(result.message, 2); &#125; &#125; this.deleteEntry = function (id) &#123; layer.confirm("确认删除入围名单吗", &#123; btn: ["确定", "取消"] &#125;, function () &#123; layer.closeAll(); $('#id' + id).remove(); itplus.toast("已删除"); itplus.ajaxPost('/entrymanagement/deleteentry', &#123; shortListId: id &#125;, function () &#123; &#125;); &#125;) &#125;&#125; EntryManagementController123456789101112131415161718192021222324252627public ActionResult GetEntryAddView() &#123; return PartialView("_EntryAdd"); &#125; public ActionResult AddEntry(EntryAddViewModel add) &#123; var model = Business.Logic&lt;EntryManagementLogic&gt;().AddEntry(add.Map&lt;EntryAddViewModel, EntryAddDTO&gt;(Constant.MapType.LowerToPascal), ClientId); if (model.success) return PartialView("_EntryListItem", model.data.Map&lt;EntryManagementDTO, EntryManagementViewModel&gt;(Constant.MapType.PascalToLower)); else return Json(new &#123; message = model.message &#125;); &#125; public ActionResult GetEntryEditView(long shortListId) &#123; var result = Business.Logic&lt;EntryManagementLogic&gt;().GetEntryListItem(shortListId, ClientId).Map&lt;EntryManagementDTO, EntryManagementViewModel&gt;(Constant.MapType.PascalToLower); return PartialView("_EntryEdit", result); &#125; public ActionResult EditEntry(EntryEditViewModel edit) &#123; var model = Business.Logic&lt;EntryManagementLogic&gt;().EditEntry(edit.Map&lt;EntryEditViewModel, EntryEditDTO&gt;(Constant.MapType.LowerToPascal), ClientId); if (model.success) return PartialView("_EntryListItem", model.data.Map&lt;EntryManagementDTO, EntryManagementViewModel&gt;(Constant.MapType.PascalToLower)); else return Json(new &#123; message = model.message &#125;); &#125; 分部页_EntryAdd.cshtml1234567&lt;div style="margin-top:10px;"&gt; @IPHtml.Form.BeginForm(new FormAttr &#123; Id = "frm", Action = "/entrymanagement/addentry" &#125;) @IPHtml.Form.Input(new InputAttr &#123; Id = "project_name", Label = "项目名称：", Required = "不能为空", MaxLength = 50, Width = 310 &#125;) @IPHtml.Form.Input(new InputAttr &#123; Id = "founder_name", Label = "主创人姓名：", Required = "不能为空", MaxLength = 50, Width = 310 &#125;) @IPHtml.Form.Submit(new SubmitAttr &#123; Id = "btnSave", Text = "确定", OnSuccess = "itplus.entry.addEntryCallBack" &#125;) @IPHtml.Form.EndPartialViewForm(new FormAttr &#123; Id = "frm" &#125;)&lt;/div&gt; 分部页_EntryEdit.cshtml12345678910@model EntryManagementViewModel&lt;div style="margin-top:10px;"&gt; @IPHtml.Form.BeginForm(new FormAttr &#123; Id = "frm", Action = "/entrymanagement/editentry" &#125;) &lt;input type="hidden" id="shortlist_id" name="shortlist_id" value="@Model.shortlist_id" /&gt; @IPHtml.Form.Input(new InputAttr &#123; Id = "project_name", Label = "项目名称：", Required = "不能为空",Value = Model.project_name, MaxLength = 50, Width = 310 &#125;) @IPHtml.Form.Input(new InputAttr &#123; Id = "founder_name", Label = "主创人姓名：", Required = "不能为空", Value = Model.founder_name,MaxLength = 50, Width = 310 &#125;) @IPHtml.Form.Submit(new SubmitAttr &#123; Id = "btnSave", Text = "确定", OnSuccess = "itplus.entry.editEntryCallBack" &#125;) @IPHtml.Form.EndPartialViewForm(new FormAttr &#123; Id = "frm" &#125;)&lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET中权限验证使用OnAuthorization实现]]></title>
    <url>%2F2019%2F09%2F17%2FASP-NET%E4%B8%AD%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E4%BD%BF%E7%94%A8OnAuthorization%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 待整理转自：https://www.cnblogs.com/HDK2016/p/8086657.htmlhttps://www.cnblogs.com/JustRun1983/p/3377652.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[C#中virtual和abstract的区别]]></title>
    <url>%2F2019%2F09%2F16%2FC-%E4%B8%ADvirtual%E5%92%8Cabstract%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 Virtual1.virtual表示成员可以在派生类中被重写。如果派生类没有重写，则直接使用父类的原始成员。2.当子类对父类的virtual方法进行override时，父类的对象通过 123BaseClass bcdc = new DerivedClass();bcdc.Method1();// 输出：Derived - Method1 调用的是子类的方法 1234567class BaseClass &#123; public virtual void Method1() &#123; Console.WriteLine("Base - Method1"); &#125; &#125; 1234567class DerivedClass : BaseClass&#123; public override void Method1() &#123; Console.WriteLine("Derived - Method1"); &#125; &#125; 3.virtual可以被子类重写,也可以不重写。4.默认情况下，非virtual的方法不能被重写。5.virtual 修饰符不能与 static、abstract、private 或 override 修饰符一起使用。6.除了声明和调用语法不同外，virtual属性的行为与抽象方法一样。 Abstract1.抽象类不能实例化。2.抽象类可以包含抽象方法和抽象访问器。3.从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实实现。 virtual和abstractvirtual和abstract都是用来修饰父类的，通过覆盖父类的定义，让子类重新定义。1.virtual修饰的方法必须有实现（哪怕是仅仅添加一对大括号),而abstract修饰的方法一定不能实现。2.virtual可以被子类重写，而abstract必须被子类重写。3.如果类成员被abstract修饰，则该类前必须添加abstract，因为只有抽象类才可以有抽象方法。4.无法创建abstract类的实例，只能被继承无法实例化。 注：部分内容转自百度知道https://zhidao.baidu.com/question/874757131434647332.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[C#--了解何时使用 Override 和 New 关键字]]></title>
    <url>%2F2019%2F09%2F16%2FC-%E4%BA%86%E8%A7%A3%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-Override-%E5%92%8C-New-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 点击查看官方连接： 1https://docs.microsoft.com/zh-cn/previous-versions/ms173153%28v%3dvs.120%29 总结：1.当子类含父类中的一样的函数，只是内容不同时，新建这个子类对象，对象调用此方法的时候，可以用new关键字排除警告2.当子类对父类的virtual方法进行override时，父类的对象通过 123BaseClass bcdc = new DerivedClass();bcdc.Method1();// 输出：Derived - Method1 调用的是子类的方法 1234567class BaseClass &#123; public virtual void Method1() &#123; Console.WriteLine("Base - Method1"); &#125; &#125; 1234567class DerivedClass : BaseClass&#123; public override void Method1() &#123; Console.WriteLine("Derived - Method1"); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[重载与重写]]></title>
    <url>%2F2019%2F09%2F16%2F%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 重载 Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。 重写 Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，相当于覆盖了父类中定义的那个完全相同的方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[C# MVC ViewModel注意事项]]></title>
    <url>%2F2019%2F09%2F12%2FC-MVC-ViewModel%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 1.DTO应该和数据库设计里的属性保持一致（主要是数据库里可为空的DTO就可为空），如下例所示： ProductSearchDTO和Product表（数据库里设计的）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384ProductSearchDTO：using ITPlus.Contract;namespace Official.BusinessLogic.DTO&#123; public class ProductSearchDTO : MvcPaging &#123; public long? ShopId &#123; get; set; &#125; public int? ClientId &#123; get; set; &#125; public int? ProductId &#123; get; set; &#125; public int? ProductTypeId &#123; get; set; &#125; public string ProductName &#123; get; set; &#125; public string Keywords &#123; get; set; &#125; public bool? Recommended &#123; get; set; &#125; &#125;&#125;Product：namespace Official.Models&#123; using System; using System.Collections.Generic; using System.ComponentModel.DataAnnotations; using System.ComponentModel.DataAnnotations.Schema; using System.Data.Entity.Spatial; [Table("Product")] public partial class Product &#123; public int ProductId &#123; get; set; &#125; [Required] [StringLength(50)] public string ProductName &#123; get; set; &#125; public int? ProductTypeGroupId &#123; get; set; &#125; public int? ProductTypeId &#123; get; set; &#125; [StringLength(50)] public string Tags &#123; get; set; &#125; [StringLength(255)] public string SmallImagePath &#123; get; set; &#125; [StringLength(255)] public string BigImagePath &#123; get; set; &#125; [StringLength(255)] public string SimpleIntro &#123; get; set; &#125; public string Intro &#123; get; set; &#125; public string Description &#123; get; set; &#125; public string ImagePaths &#123; get; set; &#125; public string FilePaths &#123; get; set; &#125; [StringLength(255)] public string Website &#123; get; set; &#125; [StringLength(50)] public string WxAppId &#123; get; set; &#125; [StringLength(255)] public string WxaQrCodePath &#123; get; set; &#125; [StringLength(50)] public string Lan &#123; get; set; &#125; public int ClientId &#123; get; set; &#125; public long? ShopId &#123; get; set; &#125; public decimal Sequence &#123; get; set; &#125; public bool Recommended &#123; get; set; &#125; public DateTime DateCreated &#123; get; set; &#125; &#125;&#125; 2.不管怎样ViewModel里的属性都不能为空（public long? shop_id { get; set; }这样是错误的），还有数据库里是DateTime类型的数据都要用string类型代替 12345678910111213using ITPlus.Contract;namespace Official.Api.ViewModel&#123; public class ProductSearchViewModel : ApiPaging &#123; public long shop_id &#123; get; set; &#125; public int client_id &#123; get; set; &#125; public int product_type_id &#123; get; set; &#125; public string product_name &#123; get; set; &#125; public bool recommended &#123; get; set; &#125; &#125;&#125; 2.1当使用Map的时候会自动把VIewModel中空的属性自动赋空 1var searchDTO = search.Map&lt;ProductSearchViewModel, ProductSearchDTO&gt;(Constant.MapType.LowerToPascal);]]></content>
  </entry>
  <entry>
    <title><![CDATA[工作中转入对象数组的例子]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E8%BD%AC%E5%85%A5%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 已添加为例 View层： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@&#123; ViewBag.Title = "添加题目";&#125;@section head&#123; &lt;style&gt; #optionLayer .is_answer .q_btn &#123; background-color: green; &#125; &lt;/style&gt;&#125;@section foot&#123; &lt;script src="@Config.API.Cdn/itplus/v2/uploader.js"&gt;&lt;/script&gt; &lt;script src="~/js/QuestionBank/add.js"&gt;&lt;/script&gt;&#125;&lt;div class="ip_container_top"&gt; &lt;div class='ip_title'&gt;添加&lt;/div&gt; &lt;a class='ip_back ip_fr' onclick="history.back()"&gt;返回&lt;/a&gt;&lt;/div&gt;@IPHtml.Form.BeginForm(new FormAttr &#123; Id = "frm", Action = "/questionbank/addquestion" &#125;)@IPHtml.Form.TextArea(new TextAreaAttr &#123; Label = "题目：", Id = "question", Height = 190, Required = "请输入题目", MaxLength = 500 &#125;)@IPHtml.Form.Image(new ImageAttr &#123; Label = "题目图片：", Id = "image_path", Text = "上传图片", Tips = "推荐750*400px,支持jpeg、jpg或png格式", Multiple = true &#125;)@IPHtml.Form.Select((List&lt;QuestionGroupSelectListViewModel&gt;)ViewBag.questionGroups, r =&gt; r.question_group_id.ToString(), r =&gt; r.question_group_name, new SelectAttr &#123; Id = "question_group_id", Label = "科目：", PlaceHolder = "全部", Required = "不能为空", IgnoreDefaultOption = true &#125;)@IPHtml.Form.Select((List&lt;QuestionTypeSelectListViewModel&gt;)ViewBag.questionTypes, r =&gt; r.question_type_id.ToString(), r =&gt; r.question_type_name, new SelectAttr &#123; Id = "question_type_id", Label = "类别：", PlaceHolder = "全部", Required = "不能为空", IgnoreDefaultOption = true &#125;)@IPHtml.Search.Select( new List&lt;IsTrueResponse&gt; &#123; new IsTrueResponse &#123; IsTrue = true, Name = "是" &#125;, new IsTrueResponse &#123; IsTrue = false, Name = "否" &#125;, &#125;, r =&gt; r.IsTrue.ToString(), r =&gt; r.Name, new SelectAttr &#123; Id = "multiple", Label = "是否多选", PlaceHolder = "是否多选", Width = 100, Required = "不能为空" &#125;)&lt;div class="btn_row"&gt; &lt;div class="ip_row inlineBlc"&gt; &lt;label class="ip_label"&gt;答案选项&lt;/label&gt; &lt;button type="button" class="ip_btn btn" onclick="itplus.questionBank.addOption()"&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;div id="optionLayer"&gt; &lt;/div&gt;&lt;/div&gt;@IPHtml.Form.Input(new InputAttr &#123; Label = "答案：", Id = "answer", Required = "请选择答案", MaxLength = 50 &#125;)@IPHtml.Form.TextArea(new TextAreaAttr &#123; Label = "题目解析：", Id = "explains", Height = 190, MaxLength = 500 &#125;)@IPHtml.Form.Submit(new SubmitAttr &#123; Id = "btnSave", OnBeforeSubmit = "itplus.questionBank.beforeSubmit", OnSuccess = "itplus.questionBank.addCallback", Text = "保存" &#125;)&lt;input type="hidden" id="optionStr" name="optionStr" /&gt;@IPHtml.Form.EndForm()@Html.Partial("_OptionModel")&lt;input hidden id="rootMenuText" value="题库-题库管理" /&gt; 注意下面的代码（1、2、3）：1、 123456789上面代码的一部分：&lt;div class="btn_row"&gt; &lt;div class="ip_row inlineBlc"&gt; &lt;label class="ip_label"&gt;答案选项&lt;/label&gt; &lt;button type="button" class="ip_btn btn" onclick="itplus.questionBank.addOption()"&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;div id="optionLayer"&gt; &lt;/div&gt;&lt;/div&gt; 2、 12345678js:itplus.questionBank = new function () &#123; ... this.addOption = function () &#123; $('#optionLayer').append($('#optionModel').html()); &#125;&#125; 3、分布页：_optionModel.cshtml: 1234567891011&lt;div id="optionModel" style="display:none;"&gt; &lt;div class="option_box mv15"&gt; &lt;label class="ip_label"&gt;&lt;/label&gt; &lt;label class="ip_label w70"&gt;选项名&lt;/label&gt; &lt;input class="ip_input w70 o_name" placeholder="请填写选项名" maxlength="50" &gt; &lt;label class="ip_label w70"&gt;选项内容&lt;/label&gt; &lt;input class="ip_input w190 o_value" placeholder="请填写选项内容" maxlength="50" &gt; &lt;button type="button" class="ip_btn btn" onclick="$(this).parent().remove()"&gt;移除&lt;/button&gt; &lt;button type="button" class="ip_btn q_btn" onclick="itplus.questionBank.changeAnswer(this)"&gt;设置答案&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 后台controller层： 12345678910public ActionResult AddQuestion(QuestionBankAddViewModel add) &#123; if (!string.IsNullOrEmpty(add.optionStr)) &#123; add.options = System.Web.Helpers.Json.Decode&lt;List&lt;QuestionOptionViewModel&gt;&gt;(add.optionStr); &#125; var model = add.Map&lt;QuestionBankAddViewModel, QuestionBankAddDTO, QuestionOptionViewModel, QuestionOptionDTO&gt;(Constant.MapType.LowerToPascal); var result = Business.Logic&lt;QuestionBankLogic&gt;().AddQuestion(model); return Json(result); &#125; QuestionBankAddViewModel: 1234567891011121314151617181920212223242526public class QuestionBankAddViewModel : QuestionBankViewModel &#123; public string optionStr &#123; get; set; &#125; public List&lt;QuestionOptionViewModel&gt; options &#123; get; set; &#125;//注意这里 &#125; public class QuestionOptionViewModel &#123; public long option_id &#123; get; set; &#125; public long question_id &#123; get; set; &#125; public string name &#123; get; set; &#125; public string option_content &#123; get; set; &#125; public bool is_answer &#123; get; set; &#125; &#125; public class QuestionBankViewModel &#123; public long question_id &#123; get; set; &#125; public int question_type_id &#123; get; set; &#125; public int question_group_id &#123; get; set; &#125; public string question &#123; get; set; &#125; public string image_path &#123; get; set; &#125; public string explains &#123; get; set; &#125; public bool multiple &#123; get; set; &#125; public string answer &#123; get; set; &#125; &#125; Logic层： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public BaseResponse AddQuestion(QuestionBankAddDTO add)&#123; var qbRep = new QuestionBankRepository(); var question = new QuestionBank &#123; Answer = add.Answer, Explains = add.Explains, ImagePath = add.ImagePath, Multiple = add.Multiple, Question = add.Question, QuestionGroupId = add.QuestionGroupId, QuestionTypeId = add.QuestionTypeId, DateCreated = DateTime.Now &#125;; qbRep.Insert(question); SaveUpdateOptions(add.Options, question.QuestionId); return new BaseResponse &#123; code = ResponseCode.Ok.code, message = "编辑成功", success = true &#125;;&#125;public void SaveUpdateOptions(List&lt;QuestionOptionDTO&gt; options, long questionId)&#123; var qoRep = new QuestionOptionRepository(); qoRep.Delete(r =&gt; r.QuestionId == questionId); if (options != null &amp;&amp; options.Count &gt; 0) &#123; var items = new List&lt;QuestionOption&gt;(); foreach (var item in options) &#123; items.Add(new QuestionOption &#123; Name = item.Name, QuestionId = questionId, OptionContent = item.OptionContent, DateCreated = DateTime.Now &#125;); &#125; qoRep.BatchAdd(items.ToArray()); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[工作中的两种删除]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 第1种：js: 123456789101112131415itplus.productParam = new function () &#123; this.deleteProductParam = function (id) &#123; layer.confirm("此操作会同时删除它的所有参数值，确认删除吗", &#123; btn: ["确定", "取消"] &#125;, function () &#123; itplus.ajaxPost('/productparam/deleteproductparam', &#123; productparamId: id &#125;, function (result) &#123; if (result.success) &#123; layer.closeAll('dialog'); $('#id_' + id).remove(); layer.msg("已删除", &#123; icon: 1, time: 1000 &#125;); &#125; else &#123; layer.msg(result.message, &#123; icon: 2 &#125;); &#125; &#125;); &#125;) &#125;&#125; 第二种：js: 1234567891011121314151617181920212223itplus.questionType = new function () &#123; this.callback = function (result) &#123; if (result.success) itplus.toast(result.message, function () &#123; layer.closeAll(); location.reload(); &#125;); else itplus.toast(result.message, 2); &#125; this.delete = function (id) &#123; layer.confirm("确认删除此分类吗？", &#123; btn: ["确定", "取消"] &#125;, function () &#123; layer.closeAll(); itplus.ajaxPost('/questiongroup/delquestiongroupdetail', &#123; question_type_id: id &#125;, function (result) &#123; if (result.success) &#123; layer.closeAll(); itplus.toast(result.message, function () &#123; location.reload(); &#125;); &#125; else itplus.toast(result.message, 2); &#125;); &#125;) &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[工作中批量传入数组如何接收并压入另一数据表]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%89%B9%E9%87%8F%E4%BC%A0%E5%85%A5%E6%95%B0%E7%BB%84%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6%E5%B9%B6%E5%8E%8B%E5%85%A5%E5%8F%A6%E4%B8%80%E6%95%B0%E6%8D%AE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 路由： 12345678910111213141516[Route("submit_test_paper")][ApiAuth][HttpPost]public DataResponse&lt;TestResultViewModel&gt; submit_test_paper([FromBody]SubmitTestPaperViewModel search)&#123; var searchDTO = search.Map&lt;SubmitTestPaperViewModel, SubmitTestPaperDTO&gt;(Constant.MapType.LowerToPascal); var result = Business.Logic&lt;QuestionBankLogic&gt;().SubmitTestPaper(searchDTO, UserId); return new DataResponse&lt;TestResultViewModel&gt; &#123; code = result.code, message = result.message, success = result.success, data = result.data.Map&lt;TestResultDTO, TestResultViewModel&gt;(Constant.MapType.PascalToLower) &#125;;&#125; Logic层： 12345678910111213141516171819202122232425262728293031323334353637383940public DataResponse&lt;TestResultDTO&gt; SubmitTestPaper(SubmitTestPaperDTO model, long userId)&#123; var rep = new TestPaperRepository(); var test = rep.First(r =&gt; r.TestPaperId == model.TestPaperId &amp;&amp; r.UserId == userId); test.Score = model.Score; test.WrongCount = model.QuestionIds.Count; test.DateConfrimed = DateTime.Now; rep.Update(test); var wrongRep = new QuetionWrongRepository(); var wrongIds = wrongRep.Where(r =&gt; r.UserId == userId).Select(r =&gt; r.QuestionId).ToList(); var questionIds = model.QuestionIds.Where(r =&gt; !wrongIds.Contains(r)); foreach (var id in questionIds) &#123; wrongRep.AddEntityToContext(new QuetionWrong &#123; DateCreated = DateTime.Now, QuestionId = id, UserId = userId &#125;); &#125; wrongRep.SaveChanges(); var bestScore = rep.Where(r =&gt; r.UserId == userId &amp;&amp; r.QuestionGroupId == model.QuestionGroupId).Select(r =&gt; r.Score).Max(); return new DataResponse&lt;TestResultDTO&gt; &#123; code = ResponseCode.Ok.code, message = "提交成功", success = true, data = new TestResultDTO &#123; TestCostTime = (test.DateConfrimed - test.DateCreated).ToString(), Score = model.Score, BestScore = bestScore &#125; &#125;;&#125; 其中下面的最为关键： 1234567891011121314var wrongRep = new QuetionWrongRepository();var wrongIds = wrongRep.Where(r =&gt; r.UserId == userId).Select(r =&gt; r.QuestionId).ToList();var questionIds = model.QuestionIds.Where(r =&gt; !wrongIds.Contains(r));foreach (var id in questionIds)&#123; wrongRep.AddEntityToContext(new QuetionWrong &#123; DateCreated = DateTime.Now, QuestionId = id, UserId = userId &#125;);&#125;wrongRep.SaveChanges(); DTO: 12345678910public class SubmitTestPaperDTO &#123; public DateTime? DateConfrimed &#123; get; set; &#125; public string ScoreSharedImagePath &#123; get; set; &#125; public int WrongCount &#123; get; set; &#125; public int Score &#123; get; set; &#125; public long TestPaperId &#123; get; set; &#125; public int QuestionGroupId &#123; get; set; &#125; public List&lt;long&gt; QuestionIds &#123; get; set; &#125;//用来接收数组 &#125; ViewModel: 1234567public class SubmitTestPaperViewModel&#123; public string score_shared_image_path &#123; get; set; &#125; public int score &#123; get; set; &#125; public long test_paper_id &#123; get; set; &#125; public List&lt;long&gt; question_ids &#123; get; set; &#125;//用来接收数组&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Postman调试的时候注意事项]]></title>
    <url>%2F2019%2F08%2F22%2FPostman%E8%B0%83%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 1.当传入的路由方法要求是匿名的时候（如下例1）要注意： 在Headers要传下面参数: 1Key:Authorization 1VALUE:0F8CF6787F7DA2DEE04C58FEBE0A452D06257C299F205885792932C63ADFE6D38C5A094D19A068120F6CC75DDED473D4BE7C8FB857BD5A5E5141E7AA393655E9B2DD4058043B48818715BFB863949B66D8DBB22B8C4368AA4D8C2DF61157E1A1691C98D28B08F8B32B43D5C0B05C6CB97F61F10119F07234F62C79D54474507BDD0244BB2B3E7B0A050E578405DF7327599311421681E44E5B24273932CB3DACA838B412495A2D1D6D9C283BBA352602 例1： 1234567891011121314151617[Route("get_question_group_list")][ApiAuth(Anonymous = true)]//这里证明是匿名的[HttpGet]public DataResponse&lt;List&lt;QuestionGroupListViewModel&gt;&gt; get_question_group_list(int question_group_id)&#123; var dto = new QuestionGroupListSearchDTO &#123; QuestionGroupId = question_group_id &#125;; var result = Business.Logic&lt;QuestionGroupLogic&gt;().GetQuestionGroupList(dto); var list = result.Map&lt;QuestionGroupListDTO, QuestionGroupListViewModel&gt;(Constant.MapType.PascalToLower); return new DataResponse&lt;List&lt;QuestionGroupListViewModel&gt;&gt; &#123; code = ResponseCode.Ok.code, message = ResponseCode.Ok.message, success = true, data = list &#125;;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[工作中框架的分页]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%A1%86%E6%9E%B6%E7%9A%84%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 1.情况一： 后台Controller： 123456789101112public ActionResult QuestionGroupList(QuestionGroupListSearchViewModel search) &#123; search.page_index = search.page_index == 0 ? 1 : search.page_index;//这几行 search.page_size = search.page_size == 0 ? 10 : search.page_size;//这几行 var dto = search.Map&lt;QuestionGroupListSearchViewModel, QuestionGroupListSearchDTO&gt;(Constant.MapType.LowerToPascal); var result = Business.Logic&lt;QuestionGroupLogic&gt;().GetQuestionGroupList(dto); var list = result.Map&lt;QuestionGroupListDTO, QuestionGroupListViewModel&gt;(Constant.MapType.PascalToLower); var data = new StaticPagedList&lt;QuestionGroupListViewModel&gt;(list, dto.PageIndex, dto.PageSize, dto.TotalCount);//这几行 return Request.IsAjaxRequest() ? (ActionResult)PartialView("_QuestionGroupList", data) : View(data);//这几行 &#125; 仓存层Repository： 123456789101112131415161718192021222324252627282930313233 public IQueryable&lt;QuestionGroupListDTO&gt; GetQuestionGroupList(QuestionGroupListSearchDTO search) &#123; var query = from qj in GetAll() join qt in DBContext.QuestionTypes on qj.QuestionGroupId equals qt.QuestionGroupId orderby qt.Sequence descending//这里排序 select new QuestionGroupListDTO &#123; QuestionGroupId = qj.QuestionGroupId, QuestionTypeId = qt.QuestionTypeId, QuestionGroupName = qj.QuestionGroupName, QuestionTypeName = qt.QuestionTypeName, Sequence = qt.Sequence, ImagePath = qt.ImagePath, TotalCount = qt.TotalCount, &#125;; if (search.QuestionGroupId.HasValue) &#123; query = query.Where(r =&gt; r.QuestionGroupId == search.QuestionGroupId); &#125; if (search.QuestionTypeId.HasValue) &#123; query = query.Where(r =&gt; r.QuestionTypeId == search.QuestionTypeId); &#125; search.TotalCount = query.Count();//这里很重要（要先排序） if (search.PageIndex &gt; 0) &#123; query = query.Skip((search.PageIndex - 1) * search.PageSize).Take(search.PageSize); &#125;// return query; &#125; 对应的View层：QuestionGroupList.cshtml: 123456789101112131415161718192021222324252627282930313233343536@model StaticPagedList&lt;QuestionGroupListViewModel&gt;@&#123; ViewBag.Title = "题库分类"; var QuestionGroupIdList = new List&lt;dynamic&gt; &#123; new &#123;id=QuestionGroupConstants.QuestionGroupId.科目一.GetHashCode().ToString(),name = QuestionGroupConstants.QuestionGroupId.科目一.ToString() &#125;, new &#123;id=QuestionGroupConstants.QuestionGroupId.科目四.GetHashCode().ToString(),name = QuestionGroupConstants.QuestionGroupId.科目四.ToString() &#125;, &#125;;&#125;@section foot&#123; &lt;script src="~/js/question_group.js"&gt;&lt;/script&gt;&#125;@section containerTop&#123; &lt;div class="ip_container_top"&gt; &lt;div class="ip_title"&gt;@ViewBag.Title&lt;/div&gt; &lt;a class="ip_create" href="/questiongroup/add"&gt;添加&lt;/a&gt; &lt;/div&gt;&#125;@IPHtml.Search.BeginSearch(new SearchAttr &#123; Action = "/questiongroup/questiongrouplist" &#125;)@IPHtml.Search.Select(QuestionGroupIdList, r =&gt; r.id, r =&gt; r.name, new SelectAttr &#123; Id = "question_group_id", Label = "科目：", PlaceHolder = "全部", Required = "不能为空", SelectedValue = Request["question_group_id"] &#125;)@IPHtml.Search.Submit(new SearchSubmitAttr &#123; Id = "question_group_list" &#125;)@IPHtml.Search.EndSearch()@IPHtml.BeginUpdateTarget(new UpdateTargetAttr &#123; Id = "question_group_list" &#125;)@Html.Partial("_QuestionGroupList", Model)@IPHtml.EndUpdateTarget() _QuestionGroupList.cshtml: 123456789101112131415161718192021@model StaticPagedList&lt;QuestionGroupListViewModel&gt;@IPHtml.List( Model, r =&gt; Html.Partial("_QuestionGroupListItem", r), new ColumnHeadAttr[] &#123; new ColumnHeadAttr &#123; Percentage=30, Head="题库科目" &#125;, new ColumnHeadAttr &#123; Percentage=30, Head="题库分类" &#125;, new ColumnHeadAttr &#123; Percentage=30, Head="操作" &#125; &#125;)//这里分页@IPHtml.Paging( Html, Model, page_index =&gt; Url.Action("QuestionGroupList", new &#123; page_index = page_index, question_group_id = Request["question_group_id"] &#125;)) _QuestionGroupListItem.cshtml: 12345678@model QuestionGroupListViewModel@IPHtml.Item(Model, r =&gt; new RowAttr &#123; Id = "id" + r.question_type_id &#125;, r =&gt; new ColumnBodyAttr[] &#123; new ColumnBodyAttr &#123; Field=r.question_group_name,Percentage=30 &#125;, new ColumnBodyAttr &#123; Field=r.question_type_name, Percentage=30 &#125;, new ColumnBodyAttr &#123; Field="&lt;a href='/questiongroup/edit/"+r.question_type_id+"' \"&gt;修改&lt;/a&gt;&lt;a onclick=\"itplus.questionType.delete("+r.question_type_id+")\"&gt;删除&lt;/a&gt;",Percentage =30 &#125;&#125;) 2.情况二：路由的Controller: 12345678910111213141516171819202122[Route("get_list")][ApiAuth(Anonymous = true)][HttpGet]public DataResponse&lt;PageResponse&lt;QuestionBankApiViewModel&gt;&gt; get_list([FromUri]QuestionBankSearchViewModel search)&#123; var searchDTO = search.Map&lt;QuestionBankSearchViewModel, QuestionBankSearchDTO&gt;(Constant.MapType.LowerToPascal); var result = Business.Logic&lt;QuestionBankLogic&gt;().GetQuestionList(searchDTO); var list = result.Map&lt;QuestionBankApiDTO, QuestionBankApiViewModel, QuestionOptionDTO, QuestionOptionListViewModel&gt;(Constant.MapType.PascalToLower); return new DataResponse&lt;PageResponse&lt;QuestionBankApiViewModel&gt;&gt; &#123; code = ResponseCode.Ok.code, message = ResponseCode.Ok.message, success = true, data = new PageResponse&lt;QuestionBankApiViewModel&gt; &#123; last_page = searchDTO.PageIndex * searchDTO.PageSize &gt;= searchDTO.TotalCount, total_count = searchDTO.TotalCount, list = list &#125; &#125;;&#125; 仓储层（Repository）的方法: 123456789101112131415161718192021222324252627282930313233343536 public IQueryable&lt;QuestionBankApiDTO&gt; GetQuestionList(QuestionBankSearchDTO search) &#123; var query = from qb in GetAll() where qb.DateDeleted == null orderby qb.QuestionId//这里排序了 select new QuestionBankApiDTO &#123; QuestionId = qb.QuestionId, Question = qb.Question, QuestionTypeId = qb.QuestionTypeId, QuestionGroupId = qb.QuestionGroupId, Answer = qb.Answer, Explains = qb.Explains, ImagePath = qb.ImagePath, Multiple = qb.Multiple, Options = DBContext.QuestionOptions.Where(r =&gt; r.QuestionId == qb.QuestionId).Select(qo =&gt; new QuestionOptionDTO &#123; OptionId = qo.OptionId, QuestionId = qo.QuestionId, Name = qo.Name, OptionContent = qo.OptionContent &#125;).ToList() &#125;; if (search.QuestionTypeId.HasValue) query = query.Where(r =&gt; r.QuestionTypeId == search.QuestionTypeId.Value); if (search.QuestionGroupId.HasValue) query = query.Where(r =&gt; r.QuestionGroupId == search.QuestionGroupId.Value); search.TotalCount = query.Count();///这里，用之前要先排序 if (search.PageIndex &gt; 0) query = query.Skip((search.PageIndex - 1) * search.PageSize).Take(search.PageSize);/// return query.AsNoTracking(); &#125; 用于搜索的ViewModel(关键是这个ApiPaging用于分页): 12345public class QuestionBankSearchViewModel : ApiPaging&#123; public int question_type_id &#123; get; set; &#125; public int question_group_id &#123; get; set; &#125;&#125; ApiPaging: 12345public class ApiPaging &#123; public int page_index &#123; get; set; &#125; public int page_size &#123; get; set; &#125; &#125; 用于搜索的DTO(关键是这个MvcPaging用于分页)： 12345public class QuestionBankSearchDTO : MvcPaging &#123; public int? QuestionTypeId &#123; get; set; &#125; public int? QuestionGroupId &#123; get; set; &#125; &#125; MvcPaging: 123456public class MvcPaging &#123; public int PageIndex &#123; get; set; &#125; public int PageSize &#123; get; set; &#125; public int TotalCount &#123; get; set; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[后台Controller层返回相关]]></title>
    <url>%2F2019%2F08%2F19%2F%E5%90%8E%E5%8F%B0Controller%E5%B1%82%E8%BF%94%E5%9B%9E%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 1.下面的代码会把结果返回给一个EventDEdit.cshtml的同名页面（参数是同步传入的）或其他页面 123456789101112public ActionResult EventDEdit(long id) &#123; var result = Business.Gateway&lt;Event_D_Gateway&gt;().GetEventList(new EventSearchViewModel &#123; event_id = id &#125;, Config.AppKey); if (result.success &amp;&amp; result.data != null &amp;&amp; result.data.list.Count &gt; 0) &#123; return View(result.data.list.First()); &#125; else &#123; return View(new EventListViewModel()); &#125; &#125; 2.从下面的代码可以看出，参数是异步传入（ajax传入）的，从return的Json格式看出。下面代码不用返回一个同名的DeleteEventD.cshtml页面或其他页面，因为她已经通过Json返回了。 1234567public ActionResult DeleteEventD(long event_id) &#123; var model = new EventDeleteViewModel &#123; event_id = event_id &#125;; var obj = Business.Gateway&lt;Event_D_Gateway&gt;().DeleteEvent(model, Config.AppKey); return Json(new BaseResponse &#123; success = obj.success, code = obj.code, message = obj.message &#125;); &#125; 3.那么如何在参数传入是同步传入的情况下（从上面的讨论可以看出，如果参数是同步传入的，必须返回一个同名页面或者通过 return View(“_OtherView”new EventListViewModel());返回另一个页面_OtherView.cshtml），返回Json呢？如下所示： 1return Json(new BaseResponse&#123; success = false, message = "无活动信息！" &#125;,JsonRequestBehavior.AllowGet);//通过JsonRequestBehavior.AllowGet]]></content>
  </entry>
  <entry>
    <title><![CDATA[c#工作中我遇到的问题--如何导出excel表]]></title>
    <url>%2F2019%2F08%2F17%2Fc-%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%88%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-%E5%A6%82%E4%BD%95%E5%AF%BC%E5%87%BAexcel%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 部分代码演示：View层：（通过Form表单提交） 123456789101112131415161718192021222324252627282930313233343536373839404142 &lt;script&gt; itplus.order = new function () &#123; this.exportOrder = function () &#123; setValue(); $('#frmExportOrder').submit(); &#125; this.exportProduct = function () &#123; setValue(); $('#frmExportProduct').submit(); &#125; var setValue = function () &#123; $('input[name=OrderNumber]').val($('#OrderNumber').val()); $('input[name=MinPrice]').val($('#MinPrice').val()); $('input[name=MaxPrice]').val($('#MaxPrice').val()); $('input[name=ShopId]').val($('#ShopId').val()); $('input[name=StatusGroupId]').val($('#StatusGroupId').val()); &#125; &lt;/script&gt;&#125;&lt;div class="exportLayer"&gt; &lt;form id="frmExportOrder" class="export" action="/order/exportorder"&gt; &lt;span class="ip_filter"&gt;&lt;button type="button" class="ip_s_btn" onclick="itplus.order.exportOrder()"&gt;导出订单表&lt;/button&gt;&lt;/span&gt; &lt;input type="hidden" name="OrderNumber" /&gt; &lt;input type="hidden" name="MinPrice" /&gt; &lt;input type="hidden" name="MaxPrice" /&gt; &lt;input type="hidden" name="ShopId" /&gt; &lt;input type="hidden" name="StatusGroupId" /&gt; &lt;/form&gt; &lt;form id="frmExportProduct" class="export" action="/order/exportproduct"&gt; &lt;span class="ip_filter"&gt;&lt;button type="button" class="ip_s_btn" onclick="itplus.order.exportProduct()"&gt;导出捡货表&lt;/button&gt;&lt;/span&gt; &lt;input type="hidden" name="OrderNumber" /&gt; &lt;input type="hidden" name="MinPrice" /&gt; &lt;input type="hidden" name="MaxPrice" /&gt; &lt;input type="hidden" name="ShopId" /&gt; &lt;input type="hidden" name="StatusGroupId" /&gt; &lt;/form&gt;&lt;/div&gt; Controller：（后台调用逻辑层和仓存层的方法略，这两层反正就是去取数据（一般是列表数据）就对了） 1234567891011121314public ActionResult ExportOrder(OrderExportViewModel search)&#123; var model = Business.Logic&lt;OrderLogic&gt;().GetOrderWithOrderLines(search.Map&lt;OrderExportViewModel, OrderSearchDTO&gt;()).Map&lt;OrderDTO, ExportOrderViewModel, OrderLineDTO, ExportOrderProductViewModel&gt;(Constant.MapType.PascalToLower); var ip_excel_html = ""; if (model.Count &gt; 0) &#123; ip_excel_html = "&lt;meta http-equiv=Content-Type content=\"text/html; charset=utf-8\"&gt;"; ip_excel_html += this.PartialViewHtml("_OrderExport", model); &#125; byte[] b = System.Text.Encoding.GetEncoding("UTF-8").GetBytes(ip_excel_html); return File(b, "application/vnd.ms-excel", "订单表.xls");&#125; 12345678910111213141516public ActionResult ExportProduct(OrderExportViewModel search)&#123; var orders = Business.Logic&lt;OrderLogic&gt;().GetOrder(search.Map&lt;OrderExportViewModel, OrderSearchDTO&gt;()); var orderLines = Business.Logic&lt;OrderLineLogic&gt;().GetOrderLine(new OrderLineSearchDTO &#123; OrderIds = orders. Select(r =&gt; r.OrderId).ToList() &#125;).Map&lt;OrderLineDTO, ExportOrderProductViewModel&gt;(Constant.MapType.PascalToLower); var ip_excel_html = ""; if (orderLines.Count &gt; 0) &#123; ip_excel_html = "&lt;meta http-equiv=Content-Type content=\"text/html; charset=utf-8\"&gt;"; ip_excel_html += this.PartialViewHtml("_OrderProductExport", orderLines); &#125; byte[] b = System.Text.Encoding.GetEncoding("UTF-8").GetBytes(ip_excel_html); return File(b, "application/vnd.ms-excel", "捡货表.xls");&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C# MVC工作中View层配置Web.Config简化命名]]></title>
    <url>%2F2019%2F08%2F16%2FC-MVC%E5%B7%A5%E4%BD%9C%E4%B8%ADView%E5%B1%82%E9%85%8D%E7%BD%AEWeb-Config%E7%AE%80%E5%8C%96%E5%91%BD%E5%90%8D%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 1.View-web.config里（把重复用的namespace放在这里） 1234567891011121314151617181920&lt;namespaces&gt; &lt;add namespace="System.Web.Mvc" /&gt; &lt;add namespace="System.Web.Mvc.Ajax" /&gt; &lt;add namespace="System.Web.Mvc.Html" /&gt; &lt;add namespace="System.Web.Routing" /&gt; &lt;add namespace="System.Web.Optimization"/&gt; &lt;add namespace="System.Linq"/&gt; &lt;add namespace="ITPlus.Module.Client.Intern" /&gt; &lt;add namespace="ITPlus.Configuration" /&gt; &lt;add namespace="ITPlus.Contract" /&gt; &lt;add namespace="ITPlus.Control" /&gt; &lt;add namespace="ITPlus.Entity" /&gt; &lt;add namespace="ITPlus.Framework" /&gt; &lt;add namespace="PagedList" /&gt; &lt;add namespace="PagedList.Mvc" /&gt; &lt;add namespace="ITPlus.Module.Client.Intern.Areas.EventArea.ViewModels" /&gt; &lt;add namespace="ITPlus.Framework.Extension" /&gt; &lt;add namespace="ITPlus.Event.Intern.C.Contract" /&gt; &lt;add namespace="ITPlus.Event.Intern.D.ViewModels" /&gt;&lt;/namespaces&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C# MVC工作中下拉框源的问题]]></title>
    <url>%2F2019%2F08%2F16%2FC-MVC%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%B8%8B%E6%8B%89%E6%A1%86%E6%BA%90%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 例子1 1234567891011121314151617181920212223242526272829303132333435363738394041@model StaticPagedList&lt;ITPlus.Event.Intern.D.ViewModels.EventDJoinViewModel&gt;@&#123; Layout = "~/Views/Shared/_Layout.cshtml"; ViewBag.Title = "报名列表";///这里很重要 var eventTypeIdList = new List&lt;dynamic&gt; &#123; new &#123;id=ITPlus.Event.Intern.D.Contract.EventConstants.EventTypeId.报名.GetHashCode().ToString(),name = ITPlus.Event.Intern.D.Contract.EventConstants.EventTypeId.报名.ToString() &#125;, new &#123;id=ITPlus.Event.Intern.D.Contract.EventConstants.EventTypeId.投票.GetHashCode().ToString(),name = ITPlus.Event.Intern.D.Contract.EventConstants.EventTypeId.投票.ToString() &#125; &#125;;///&#125;@section head&#123; &lt;style&gt; .ip_form_select .ip_input &#123; width: 140px !important; &#125; #user_name &#123; width: 160px !important; &#125; &lt;/style&gt;&#125;@section containerTop&#123; &lt;div class="ip_container_top"&gt; &lt;div class="ip_title"&gt;报名列表&lt;/div&gt; &lt;/div&gt;&#125;@IPHtml.Search.BeginSearch(new SearchAttr &#123; Id = "frm", Action = "/event/eventdjoinlist" &#125;)@IPHtml.Search.Select(eventTypeIdList, r =&gt; r.id, r =&gt; r.name, new SelectAttr &#123; Id = "event_type_id", Label = "活动类型：", PlaceHolder = "全部", Required = "不能为空" &#125;)@IPHtml.Search.Input(new InputAttr &#123; Id = "mobile", Label = "手机：", Width = 200, PlaceHolder = "请输入手机" &#125;)@IPHtml.Search.Submit(new SearchSubmitAttr &#123; Id = "btnSubmit", UpdateTargetId = "data_list" &#125;)@IPHtml.Search.EndSearch()@IPHtml.BeginUpdateTarget(new UpdateTargetAttr &#123; Id = "data_list" &#125;)@Html.Partial("_EventDJoinList", Model)@IPHtml.EndUpdateTarget() Constants.cs里的常量 12345678public class Constants&#123; public enum EventTypeId &#123; 报名 = 1, 投票 = 2 &#125;&#125; 例子2 12345678910111213141516@IPHtml.Form.Select( new List&lt;dynamic&gt; &#123; new &#123; Status = (int)Constants.Gender.女+"", Name = "女"&#125;, new &#123; Status = (int)Constants.Gender.男+"", Name = "男" &#125; &#125;, r =&gt; r.Status, r =&gt; r.Name, new SelectAttr &#123; Id = "gender", //用于接收的ViewModel里的gender为int（int gender） Label = "性别：", SelectedValue = Model.gender, Required = "性别不能为空！", IgnoreDefaultOption = true&#125;) Constants.cs里的常量 12345678public class Constants&#123; public enum Gender &#123; 男 = 1, 女 = 2 &#125;&#125; 例子3 12345678910111213@IPHtml.Form.RadioButton( new List&lt;dynamic&gt; &#123; new &#123; name = "男", value = "1" &#125;, new &#123; name = "女", value = "2" &#125; &#125;, r =&gt; r.value, r =&gt; r.name, new RadioButtonAttr &#123; Id = "gender", //用于接收的ViewModel里的gender为int（int gender） Label = "性别：" &#125;) 例子4 123456789101112131415161718192021222324252627282930313233343536373839@model StaticPagedList&lt;ITPlus.Event.Intern.D.ViewModels.EventDJoinViewModel&gt;@&#123; Layout = "~/Views/Shared/_Layout.cshtml"; ViewBag.Title = "报名列表"; var eventTypeIdList = new List&lt;dynamic&gt; &#123; new &#123;id=ITPlus.Event.Intern.D.Contract.EventConstants.EventTypeId.报名.GetHashCode().ToString(),name = ITPlus.Event.Intern.D.Contract.EventConstants.EventTypeId.报名.ToString() &#125;, new &#123;id=ITPlus.Event.Intern.D.Contract.EventConstants.EventTypeId.投票.GetHashCode().ToString(),name = ITPlus.Event.Intern.D.Contract.EventConstants.EventTypeId.投票.ToString() &#125; &#125;;&#125;@section head&#123; &lt;style&gt; .ip_form_select .ip_input &#123; width: 140px !important; &#125; #user_name &#123; width: 160px !important; &#125; &lt;/style&gt;&#125;@section containerTop&#123; &lt;div class="ip_container_top"&gt; &lt;div class="ip_title"&gt;报名列表&lt;/div&gt; &lt;/div&gt;&#125;@IPHtml.Search.BeginSearch(new SearchAttr &#123; Id = "frm", Action = "/event/eventdjoinlist" &#125;)@IPHtml.Search.Select(eventTypeIdList, r =&gt; r.id, r =&gt; r.name, new SelectAttr &#123; Id = "event_type_id", Label = "活动类型：", PlaceHolder = "全部", Required = "不能为空" &#125;) //用于接收的ViewModel里的event_type_id为int（int event_type_id,）@IPHtml.Search.Input(new InputAttr &#123; Id = "mobile", Label = "手机：", Width = 200, PlaceHolder = "请输入手机" &#125;)@IPHtml.Search.Submit(new SearchSubmitAttr &#123; Id = "btnSubmit", UpdateTargetId = "data_list" &#125;)@IPHtml.Search.EndSearch()@IPHtml.BeginUpdateTarget(new UpdateTargetAttr &#123; Id = "data_list" &#125;)@Html.Partial("_EventDJoinList", Model)@IPHtml.EndUpdateTarget() EventConstants.cs里的常量 12345678public class EventConstants&#123; public enum EventTypeId &#123; 报名 = 1, 投票 = 2 &#125;&#125; 例子5（最常用的）一般是Controller层： 12345678910public ActionResult ServiceList(ServiceAdminSearchViewModel search ,int page_index = 1)&#123; var searchModel = search.Map&lt;ServiceAdminSearchViewModel, ServiceAdminSearchDTO&gt;(Constant.MapType.LowerToPascal); ViewBag.tags = Business.Logic&lt;DriverSchoolLogic&gt;().GetDriverSchoolList(searchModel).Map&lt;DriverSchoolSelectListDTO, DriverSchoolSelectListViewModel&gt;(Constant.MapType.PascalToLower); //这里很重要 searchModel.PageIndex = page_index; searchModel.PageSize = 10; var model = Business.Logic&lt;ServiceLogic&gt;().GetServiceAdminList(searchModel); var data = new StaticPagedList&lt;ServiceAdminListViewModel&gt;(model.Map&lt;ServiceAdminListDTO, ServiceAdminListViewModel,DriverSchoolSelectListDTO,DriverSchoolListViewModel&gt;(Constant.MapType.PascalToLower), searchModel.PageIndex, searchModel.PageSize, searchModel.TotalCount); return Request.IsAjaxRequest()? (ActionResult)PartialView("_ServiceList", data) : View(data);&#125; View层 1234567891011@IPHtml.Search.Select((List&lt;DriverSchoolSelectListViewModel&gt;)ViewBag.tags, //ViewBag.tags的作用--数据源 r =&gt; r.driver_school_id.ToString(), r =&gt; r.school_name, new SelectAttr &#123; Id = "driver_school_id", Label = "所属驾校：", OptionValue = "", OptionText = "不限", SelectedValue = Request["driver_school_id"], &#125;) 例子612345678910111213@IPHtml.Search.Select( new List&lt;IsTrueResponse&gt; &#123; new IsTrueResponse &#123; IsTrue = true, Name = "是" &#125;, new IsTrueResponse &#123; IsTrue = false, Name = "否" &#125;, &#125;, r =&gt; r.IsTrue.ToString(), r =&gt; r.Name, new SelectAttr &#123; Id = "multiple", Label = "是否多选", PlaceHolder = "是否多选", SelectedValue = Model.multiple, Width = 100, Required = "不能为空" &#125;) 1Model.multiple是bool型的]]></content>
  </entry>
  <entry>
    <title><![CDATA[接下来要做的]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%A6%81%E5%81%9A%E7%9A%84%2F</url>
    <content type="text"><![CDATA[数据表连接练习，码表，out，下拉框]]></content>
  </entry>
  <entry>
    <title><![CDATA[工作中C# MVC接口路由的一些命名习惯]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%B7%A5%E4%BD%9C%E4%B8%ADC-MVC%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E5%90%8D%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 1.接口路由名和方法名保持一致（[Route(“get_event_join_list”)]和get_event_join_list）要保持一致1234567891011121314151617181920[Route("get_event_join_list")][HttpGet]public DataResponse&lt;PageResponse&lt;EventDJoinViewModel&gt;&gt; get_event_join_list([FromUri]EventJoinSearchViewModel search)&#123; var searchDTO = search.Map&lt;EventJoinSearchViewModel, EventJoinSearchDTO&gt;(Constant.MapType.LowerToPascal); var result = Business.Logic&lt;EventLogic&gt;().GetEventJoinList(searchDTO, AppKey); return new DataResponse&lt;PageResponse&lt;EventDJoinViewModel&gt;&gt; &#123; success = true, code = ResponseCode.Ok.code, message = ResponseCode.Ok.message, data = new PageResponse&lt;EventDJoinViewModel&gt; &#123; last_page = searchDTO.PageIndex * searchDTO.PageSize &gt;= searchDTO.TotalCount, total_count = searchDTO.TotalCount, list = result.Map&lt;EventDJoinDTO, EventDJoinViewModel&gt;(Constant.MapType.PascalToLower) &#125; &#125;;&#125; 1.1接口路由方法名也要和逻辑层和仓存储的方法保持一致，如上面的get_event_join_list和GetEventJoinList逻辑层： 1234public List&lt;EventDJoinDTO&gt; GetEventJoinList(EventJoinSearchDTO search, string appKey)&#123; return new EventRepository().GetEventJoinList(search, appKey).ToList();&#125; 仓存储： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public IQueryable&lt;EventDJoinDTO&gt; GetEventJoinList(EventJoinSearchDTO search, string appKey)&#123; var query = from e in GetAll() join ej in DBContext.EventJoins on e.EventId equals ej.EventId join t in DBContext.EventTypes on e.EventTypeId equals t.EventTypeId join tg in DBContext.EventTypeGroups on t.EventTypeGroupId equals tg.EventTypeGroupId where e.AppKey == appKey &amp;&amp; !e.DateDeleted.HasValue orderby ej.OrderId select new EventDJoinDTO &#123; AppKey = e.AppKey, Title = e.Title, EventAddress = e.EventAddress, Description = e.Description, EventId = e.EventId, ShopId = e.ShopId, OrderId = ej.OrderId, UserId = ej.UserId, DateDeleted = e.DateDeleted, DateCreated = e.DateCreated, ClientId = e.ClientId, CategoryId = e.CategoryId, Price = e.Price, EventTypeId = e.EventTypeId, EventTypeName = t.EventTypeName, EventTypeGroupId = tg.EventTypeGroupId, EventTypeGroupName = tg.EventTypeGroupName, UserName = ej.UserName, Mobile = ej.Mobile, Note = ej.Note, ImagePaths = ej.ImagePaths, VideoJson = ej.VideoJson, EventDateFrom = e.EventDateFrom, EventDateTo = e.EventDateTo &#125;; if (search.EventId.HasValue) &#123; query = query.Where(r =&gt; r.EventId == search.EventId); &#125; if (search.OrderId.HasValue) &#123; query = query.Where(r =&gt; r.OrderId == search.OrderId); &#125; if (search.EventTypeId.HasValue) &#123; query = query.Where(r =&gt; r.EventTypeId == search.EventTypeId.Value); &#125; if (search.EventTypeGroupId.HasValue) &#123; query = query.Where(r =&gt; r.EventTypeGroupId == search.EventTypeGroupId); &#125; if (search.UserId.HasValue) &#123; query = query.Where(r =&gt; r.UserId == search.UserId); &#125; if (!string.IsNullOrWhiteSpace(search.Mobile)) &#123; query = query.Where(r =&gt; r.Mobile.Contains(search.Mobile)); &#125; if (search.PageIndex &gt; 0) &#123; search.TotalCount = query.Count(); query = query.Skip((search.PageIndex - 1) * search.PageSize).Take(search.PageSize); &#125; return query.AsNoTracking();&#125; 1.2接口(api的controller层)路由方法传入单个参数的时候要用（int order_id，int event_id）这样的命名方式1234567891011121314[Route("get_event_join_detail")][HttpGet]public DataResponse&lt;EventDJoinViewModel&gt; get_event_join_detail(int order_id)&#123; var result = Business.Logic&lt;EventLogic&gt;().GetEventDJoinDetail(new EventJoinSearchDTO &#123; OrderId = order_id &#125;, AppKey); return new DataResponse&lt;EventDJoinViewModel&gt; &#123; success = true, code = ResponseCode.Ok.code, message = ResponseCode.Ok.message, data = result.Map&lt;EventDJoinDTO, EventDJoinViewModel&gt;(Constant.MapType.PascalToLower) &#125;;&#125; 1.2.1后台controller层传入单个参数的时候可以用(int eventId)这样的方式，第一个字母小写，之后单词的第一个字母都大写123456public ActionResult Forbidden(long eventId) &#123; var dto = new ForbiddenEventViewModel &#123; event_id = eventId, user_id = UserId.Value &#125;; var obj = Business.Gateway&lt;Event_C_Gateway&gt;().ForbiddenEvent(dto); return Json(new BaseResponse &#123; success = obj.success, code = obj.code, message = obj.message &#125;); &#125; 2.ViewModel和DTO自由属性的命名规范2.1Viewmodel:(根据需要返回需要的属性，给Controller层传参或者返回)123456789101112131415161718using System;namespace AlaGou.Admin.ViewModel&#123; public class HouseViewModel &#123; public int? house_id &#123; get; set; &#125; public string title &#123; get; set; &#125; public int client_id &#123; get; set; &#125; public string price &#123; get; set; &#125; public string tag &#123; get; set; &#125; public DateTime date_created &#123; get; set; &#125; &#125; public class HouseDetailViewModel : HouseViewModel &#123; public string cover_image_path &#123; get; set; &#125; public string description &#123; get; set; &#125; &#125;&#125; 2.2DTO:(和数据库里设计的属性保持一致，给逻辑层和仓储层用的对象)///HouseDTO(如下)，可以直接继承House表（数据库里自己设计的表，一般在一个项目的Model中），省去再写属性的麻烦 123456789using System.ComponentModel.DataAnnotations.Schema;using AlaGou.Models;namespace AlaGou.BusinessLogic.DTO&#123; [NotMapped] public class HouseDTO : House &#123; &#125;&#125; ///HouseEditDTO（如下） 1234567using AlaGou.Models;namespace AlaGou.BusinessLogic.DTO&#123; public class HouseEditDTO : House &#123; &#125;&#125; ///HouseSearchDTO（如下） 1234567891011121314using ITPlus.Contract;using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace AlaGou.BusinessLogic.DTO&#123; public class HouseSearchDTO : MvcPaging &#123; public string Title &#123; get; set; &#125; public string Tag &#123; get; set; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[EF实体对象变动跟踪]]></title>
    <url>%2F2019%2F08%2F07%2FEF%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1%E5%8F%98%E5%8A%A8%E8%B7%9F%E8%B8%AA%2F</url>
    <content type="text"><![CDATA[转载：https://blog.csdn.net/u011127019/article/details/53941235]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linq中的Join使用笔记]]></title>
    <url>%2F2019%2F08%2F07%2FLinq%E4%B8%AD%E7%9A%84Join%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[转载：https://blog.csdn.net/deaoe/article/details/85224733]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linq教程（待概括）]]></title>
    <url>%2F2019%2F08%2F07%2FLinq%E6%95%99%E7%A8%8B%EF%BC%88%E5%BE%85%E6%A6%82%E6%8B%AC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 在说LINQ之前必须先说说几个重要的C#语言特性 一：与LINQ有关的语言特性 1.隐式类型 （1）源起 在隐式类型出现之前, 我们在声明一个变量的时候, 总是要为一个变量指定他的类型 甚至在foreach一个集合的时候， 也要为遍历的集合的元素，指定变量的类型 隐式类型的出现， 程序员就不用再做这个工作了。 （2）使用方法 来看下面的代码： var a = 1; //int a = 1; var b = “123”;//string b = “123”; var myObj = new MyObj();//MyObj myObj = new MyObj() 上面的每行代码，与每行代码后面的注释，起到的作用是完全一样的 也就是说，在声明一个变量（并且同时给它赋值）的时候，完全不用指定变量的类型，只要一个var就解决问题了 （3）你担心这样写会降低性能吗？ 我可以负责任的告诉你，这样写不会影响性能！ 上面的代码和注释里的代码，编译后产生的IL代码（中间语言代码）是完全一样的 （编译器根据变量的值，推导出变量的类型，才产生的IL代码） （4）这个关键字的好处： 你不用在声明一个变量并给这个变量赋值的时候，写两次变量类型 （这一点真的为开发者节省了很多时间） 在foreach一个集合的时候，可以使用var关键字来代替书写循环变量的类型 （5）注意事项 你不能用var关键字声明一个变量而不给它赋值 因为编译器无法推导出你这个变量是什么类型的。 2.匿名类型 (1)源起 创建一个对象，一定要先定义这个对象的类型吗？ 不一定的！ 来看看这段代码 （2）使用 var obj = new {Guid.Empty, myTitle = &quot;匿名类型&quot;, myOtherParam = new int[] { 1, 2, 3, 4 } }; Console.WriteLine(obj.Empty);//另一个对象的属性名字，被原封不动的拷贝到匿名对象中来了。 Console.WriteLine(obj.myTitle); Console.ReadKey(); new关键字之后就直接为对象定义了属性，并且为这些属性赋值 而且，对象创建出来之后，在创建对象的方法中，还可以畅通无阻的访问对象的属性 当把一个对象的属性拷贝到匿名对象中时，可以不用显示的指定属性的名字，这时原始属性的名字会被“拷贝”到匿名对象中 （3）注意 如果你监视变量obj，你会发现，obj的类型是Anonymous Type类型的 不要试图在创建匿名对象的方法外面去访问对象的属性！ （4）优点 这个特性在网站开发中，序列化和反序列化JSON对象时很有用 3.自动属性 （1）源起 为一个类型定义属性，我们一般都写如下的代码： public class MyObj2 { private Guid _id; private string _Title; public Guid id { get { return _id; } set { _id = value; } } public string Title { get { return _Title; } set { _Title = value; } } } 但很多时候，这些私有变量对我们一点用处也没有，比如对象关系映射中的实体类。 自C#3.0引入了自动实现的属性， 以上代码可以写成如下形式： （2）使用 public class MyObj { public Guid id { get; set; } public string Title { get; set; } } 这个特性也和var关键字一样，是编译器帮我们做了工作，不会影响性能的 4.初始化器 （1）源起 我们创建一个对象并给对象的属性赋值，代码一般写成下面的样子 var myObj = new MyObj(); myObj.id = Guid.NewGuid(); myObj.Title = &quot;allen&quot;; 自C#3.0引入了对象初始化器， 代码可以写成如下的样子 （2）使用 var myObj1 = new MyObj() { id = Guid.NewGuid(), Title = “allen” }; 如果一个对象是有参数的构造函数 那么代码看起来就像这样 var myObj1 = new MyObj (“allen”) { id = Guid.NewGuid(), Title = “allen” }; 集合初始化器的样例代码如下： var arr = new List() { 1, 2, 3, 4, 5, 6 }; （3）优点 我个人认为：这个特性不是那么amazing， 这跟我的编码习惯有关，集合初始化器也就罢了， 真的不习惯用对象初始化器初始化一个对象！ 5.委托 （1）使用 我们先来看一个简单的委托代码 delegate Boolean moreOrlessDelgate(int item); class Program { static void Main(string[] args) { var arr = new List&lt;int&gt;() { 1, 2, 3, 4, 5, 6,7,8 }; var d1 = new moreOrlessDelgate(More); Print(arr, d1); Console.WriteLine(&quot;OK&quot;); var d2 = new moreOrlessDelgate(Less); Print(arr, d2); Console.WriteLine(&quot;OK&quot;); Console.ReadKey(); } static void Print(List&lt;int&gt; arr,moreOrlessDelgate dl) { foreach (var item in arr) { if (dl(item)) { Console.WriteLine(item); } } } static bool More(int item) { if (item &gt; 3) { return true; } return false; } static bool Less(int item) { if (item &lt; 3) { return true; } return false; } } 这段代码中 &lt;1&gt;首先定义了一个委托类型 delegate Boolean moreOrlessDelgate(int item); 你看到了，委托和类是一个级别的，确实是这样：委托是一种类型 和class标志的类型不一样，这种类型代表某一类方法。 这一句代码的意思是：moreOrlessDelgate这个类型代表返回值为布尔类型，输入参数为整形的方法 &lt;2&gt;有类型就会有类型的实例 var d1 = new moreOrlessDelgate(More); var d2 = new moreOrlessDelgate(Less); 这两句就是创建moreOrlessDelgate类型实例的代码， 它们的输入参数是两个方法 &lt;3&gt;有了类型的实例，就会有操作实例的代码 Print(arr, d1); Print(arr, d2); 我们把前面两个实例传递给了Print方法 这个方法的第二个参数就是moreOrlessDelgate类型的 在Print方法内用如下代码，调用委托类型实例所指向的方法 dl(item) 6.泛型 (1)为什么要有泛型 假设你是一个方法的设计者， 这个方法有一个传入参数，有一个返回值。 但你并不知道这个参数和返回值是什么类型的， 如果没有泛型，你可能把参数和返回值的类型都设定为Object了 那时，你心里肯定在想：反正一切都是对象，一切的基类都是Object 没错！你是对的！ 这个方法的消费者，会把他的对象传进来（有可能会做一次装箱操作） 并且得到一个Object的返回值，他再把这个返回值强制类型转化为他需要的类型 除了装箱和类型转化时的性能损耗外，代码工作的很好！ 那么这些性能损耗能避免掉吗？ 有泛型之后就可以了！ （2）使用 &lt;1&gt;使用简单的泛型 先来看下面的代码： var intList = new List&lt;int&gt;() { 1,2,3}; intList.Add(4); intList.Insert(0, 5); foreach (var item in intList) { Console.WriteLine(item); } Console.ReadKey(); 在上面这段代码中我们声明了一个存储int类型的List容器 并循环打印出了容器里的值 注意：如果这里使用Hashtable、Queue或者Stack等非泛型的容器 就会导致装箱操作，损耗性能。因为这些容器只能存储Object类型的数据 &lt;2&gt;泛型类型 List、Dictionary&lt;TKey, TValue&gt;等泛型类型都是.net类库定义好并提供给我们使用的 但在实际开发中，我们也经常需要定义自己的泛型类型 来看下面的代码： public static class SomethingFactory&lt;T&gt; { public static T InitInstance(T inObj) { if (false)//你的判断条件 { //do what you want... return inObj; } return default(T); } } 这段代码的消费者如下： var a1 = SomethingFactory&lt;int&gt;.InitInstance(12); Console.WriteLine(a1); Console.ReadKey(); 输出的结果为0 这就是一个自定义的静态泛型类型， 此类型中的静态方法InitInstance对传入的参数做了一个判断 如果条件成立，则对传入参数进行操作之后并把它返回 如果条件不成立，则返回一个空值 注意： [1] 传入参数必须为指定的类型， 因为我们在使用这个泛型类型的时候，已经规定好它能接收什么类型的参数 但在设计这个泛型的时候，我们并不知道使用者将传递什么类型的参数进来 [2] 如果你想返回T类型的空值，那么请用default(T)这种形式 因为你不知道T是值类型还是引用类型，所以别擅自用null &lt;3&gt;泛型约束 很多时候我们不希望使用者太过自由 我们希望他们在使用我们设计的泛型类型时 不要很随意的传入任何类型 对于泛型类型的设计者来说，要求使用者传入指定的类型是很有必要的 因为我们只有知道他传入了什么东西，才方便对这个东西做操作 让我们来给上面设计的泛型类型加一个泛型约束 代码如下： public static class SomethingFactory where T:MyObj 这样在使用SomethingFactory的时候就只能传入MyObj类型或MyObj的派生类型啦 注意： 还可以写成这样 where T:MyObj,new() 来约束传入的类型必须有一个构造函数。 （3）泛型的好处 &lt;1&gt;算法的重用 想想看：list类型的排序算法，对所有类型的list集合都是有用的 &lt;2&gt;类型安全 &lt;3&gt;提升性能 没有类型转化了，一方面保证类型安全，另一方面保证性能提升 &lt;4&gt;可读性更好 这一点就不解释了 7.泛型委托 （1）源起 委托需要定义delgate类型 使用起来颇多不便 而且委托本就代表某一类方法 开发人员经常使用的委托基本可以归为三类， 哪三类呢？ 请看下面： （2）使用 &lt;1&gt;Predicate泛型委托 把上面例子中d1和d2赋值的两行代码改为如下： //var d1 = new moreOrlessDelgate(More); var d1 = new Predicate&lt;int&gt;(More); //var d2 = new moreOrlessDelgate(Less); var d2 = new Predicate&lt;int&gt;(Less); 把Print方法的方法签名改为如下： //static void Print(List&lt;int&gt; arr, moreOrlessDelgate&lt;int&gt; dl) static void Print(List&lt;int&gt; arr, Predicate&lt;int&gt; dl) 然后再运行方法，控制台输出的结果和原来的结果是一模一样的。 那么Predicate到底是什么呢？ 来看看他的定义： // 摘要: // 表示定义一组条件并确定指定对象是否符合这些条件的方法。 // // 参数: // obj: // 要按照由此委托表示的方法中定义的条件进行比较的对象。 // // 类型参数: // T: // 要比较的对象的类型。 // // 返回结果: // 如果 obj 符合由此委托表示的方法中定义的条件，则为 true；否则为 false。 public delegate bool Predicate&lt;in T&gt;(T obj); 看到这个定义，我们大致明白了。 .net为我们定义了一个委托， 这个委托表示的方法需要传入一个T类型的参数，并且需要返回一个bool类型的返回值 有了它，我们就不用再定义moreOrlessDelgate委托了， 而且，我们定义的moreOrlessDelgate只能搞int类型的参数， Predicate却不一样，它可以搞任意类型的参数 但它规定的还是太死了，它必须有一个返回值，而且必须是布尔类型的，同时，它必须有一个输入参数 除了Predicate泛型委托，.net还为我们定义了Action和Func两个泛型委托 &lt;2&gt;Action泛型委托 Action泛型委托限制的就不那么死了， 他代表了一类方法： 可以有0个到16个输入参数， 输入参数的类型是不确定的， 但不能有返回值， 来看个例子： var d3 = new Action(noParamNoReturnAction); var d4 = new Action&lt;int, string&gt;(twoParamNoReturnAction); 注意：尖括号中int和string为方法的输入参数 static void noParamNoReturnAction() { //do what you want } static void twoParamNoReturnAction(int a, string b) { //do what you want } &lt;3&gt;Func泛型委托 为了弥补Action泛型委托，不能返回值的不足 .net提供了Func泛型委托， 相同的是它也是最多0到16个输入参数，参数类型由使用者确定 不同的是它规定要有一个返回值，返回值的类型也由使用者确定 如下示例： var d5 = new Func&lt;int, string&gt;(oneParamOneReturnFunc); 注意：string类型（最后一个泛型类型）是方法的返回值类型 static string oneParamOneReturnFunc(int a) { //do what you want return string.Empty; } 8.匿名方法 （1）源起 在上面的例子中 为了得到序列中较大的值 我们定义了一个More方法 var d1 = new Predicate(More); 然而这个方法，没有太多逻辑（实际编程过程中，如果逻辑较多，确实应该独立一个方法出来） 那么能不能把More方法中的逻辑，直接写出来呢？ C#2.0之后就可以了， 请看下面的代码： （2）使用 var arr = new List&lt;int&gt;() { 1, 2, 3, 4, 5, 6, 7, 8 }; //var d1 = new moreOrlessDelgate(More); //var d1 = new Predicate&lt;int&gt;(More); var d1 = new Predicate&lt;int&gt;(delegate(int item) { //可以访问当前上下文中的变量 Console.WriteLine(arr.Count); if (item &gt; 3) { return true; } return false; }); Print(arr, d1); Console.WriteLine(&quot;OK&quot;); 我们传递了一个代码块给Predicate的构造函数 其实这个代码块就是More函数的逻辑 （3）好处 &lt;1&gt;代码可读性更好 &lt;2&gt;可以访问当前上下文中的变量 这个用处非常大， 如果我们仍旧用原来的More函数 想要访问arr变量，势必要把arr写成类级别的私有变量了 用匿名函数的话，就不用这么做了。 9.Lambda表达式 （1）源起 .net的设计者发现在使用匿名方法时， 仍旧有一些多余的字母或单词的编码工作 比如delegate关键字 于是进一步简化了匿名方法的写法 （2）使用 List&lt;int&gt; arr = new List&lt;int&gt;() { 1, 2, 3, 4, 5, 6, 7 }; arr.ForEach(new Action&lt;int&gt;(delegate(int a) { Console.WriteLine(a); })); arr.ForEach(new Action&lt;int&gt;(a =&gt; Console.WriteLine(a))); 匿名方法的代码如下： delegate(int a) { Console.WriteLine(a); } 使用lambda表达式的代码如下： a =&gt; Console.WriteLine(a) 这里解释一下这个lambda表达式 &lt;1&gt; a是输入参数，编译器可以自动推断出它是什么类型的， 如果没有输入参数，可以写成这样： () =&gt; Console.WriteLine(“ddd”) &lt;2&gt; =&gt;是lambda操作符 &lt;3&gt; Console.WriteLine(a)是要执行的语句。 如果是多条语句的话，可以用{}包起来。 如果需要返回值的话，可以直接写return语句 10.扩展方法 （1）源起 如果想给一个类型增加行为，一定要通过继承的方式实现吗？ 不一定的！ （2）使用 来看看这段代码： public static void PrintString(this String val) { Console.WriteLine(val); } 消费这段代码的代码如下： var a = &quot;aaa&quot;; a.PrintString(); Console.ReadKey(); 我想你看到扩展方法的威力了。 本来string类型没有PrintString方法 但通过我们上面的代码，就给string类型”扩展”了一个PrintString方法 （1）先决条件 &lt;1&gt;扩展方法必须在一个非嵌套、非泛型的静态类中定义 &lt;2&gt;扩展方法必须是一个静态方法 &lt;3&gt;扩展方法至少要有一个参数 &lt;4&gt;第一个参数必须附加this关键字作为前缀 &lt;5&gt;第一个参数不能有其他修饰符（比如ref或者out） &lt;6&gt;第一个参数不能是指针类型 （2）注意事项 &lt;1&gt;跟前面提到的几个特性一样，扩展方法只会增加编译器的工作，不会影响性能（用继承的方式为一个类型增加特性反而会影响性能） &lt;2&gt;如果原来的类中有一个方法，跟你的扩展方法一样（至少用起来是一样），那么你的扩展方法奖不会被调用，编译器也不会提示你 &lt;3&gt;扩展方法太强大了，会影响架构、模式、可读性等等等等…. 11.迭代器 · （1）使用 我们每次针对集合类型编写foreach代码块，都是在使用迭代器 这些集合类型都实现了IEnumerable接口 都有一个GetEnumerator方法 但对于数组类型就不是这样 编译器把针对数组类型的foreach代码块 替换成了for代码块。 来看看List的类型签名： public class List : IList, ICollection, IEnumerable, IList, ICollection, IEnumerable IEnumerable接口，只定义了一个方法就是： IEnumerator GetEnumerator(); （2）迭代器的优点： 假设我们需要遍历一个庞大的集合 只要集合中的某一个元素满足条件 就完成了任务 你认为需要把这个庞大的集合全部加载到内存中来吗？ 当然不用（C#3.0之后就不用了）！ 来看看这段代码： static IEnumerable&lt;int&gt; GetIterator() { Console.WriteLine(&quot;迭代器返回了1&quot;); yield return 1; Console.WriteLine(&quot;迭代器返回了2&quot;); yield return 2; Console.WriteLine(&quot;迭代器返回了3&quot;); yield return 3; } 消费这个函数的代码如下： foreach (var i in GetIterator()) { if (i == 2) { break; } Console.WriteLine(i); } Console.ReadKey(); 输出结果为： 迭代器返回了1 1 迭代器返回了2 大家可以看到： 当迭代器返回2之后，foreach就退出了 并没有输出“迭代器返回了3” 也就是说下面的工作没有做。 （3）yield 关键字 MSDN中的解释如下： 在迭代器块中用于向枚举数对象提供值或发出迭代结束信号。 也就是说，我们可以在生成迭代器的时候，来确定什么时候终结迭代逻辑 上面的代码可以改成如下形式： static IEnumerable&lt;int&gt; GetIterator() { Console.WriteLine(&quot;迭代器返回了1&quot;); yield return 1; Console.WriteLine(&quot;迭代器返回了2&quot;); yield break; Console.WriteLine(&quot;迭代器返回了3&quot;); yield return 3; } (4)注意事项 &lt;1&gt;做foreach循环时多考虑线程安全性 在foreach时不要试图对被遍历的集合进行remove和add等操作 任何集合，即使被标记为线程安全的，在foreach的时候，增加项和移除项的操作都会导致异常 （我在这里犯过错） &lt;2&gt;IEnumerable接口是LINQ特性的核心接口 只有实现了IEnumerable接口的集合 才能执行相关的LINQ操作，比如select,where等 这些操作，我们接下来会讲到。 二：LINQ 1.查询操作符 （1）源起 .net的设计者在类库中定义了一系列的扩展方法 来方便用户操作集合对象 这些扩展方法构成了LINQ的查询操作符 （2）使用 这一系列的扩展方法，比如： Where，Max，Select，Sum，Any，Average，All，Concat等 都是针对IEnumerable的对象进行扩展的 也就是说，只要实现了IEnumerable接口，就可以使用这些扩展方法 来看看这段代码： List&lt;int&gt; arr = new List&lt;int&gt;() { 1, 2, 3, 4, 5, 6, 7 }; var result = arr.Where(a =&gt; { return a &gt; 3; }).Sum(); Console.WriteLine(result); Console.ReadKey(); 这段代码中，用到了两个扩展方法。 &lt;1&gt; Where扩展方法，需要传入一个Func&lt;int,bool&gt;类型的泛型委托 这个泛型委托，需要一个int类型的输入参数和一个布尔类型的返回值 我们直接把a =&gt; { return a &gt; 3; }这个lambda表达式传递给了Where方法 a就是int类型的输入参数，返回a是否大于3的结果。 &lt;2&gt; Sum扩展方法计算了Where扩展方法返回的集合的和。 （3）好处 上面的代码中 arr.Where(a =&gt; { return a &gt; 3; }).Sum(); 这一句完全可以写成如下代码： (from v in arr where v &gt; 3 select v).Sum(); 而且两句代码的执行细节是完全一样的 大家可以看到,第二句代码更符合语义，更容易读懂 第二句代码中的where，就是我们要说的查询操作符。 （4）标准查询操作符说明 &lt;1&gt;过滤 Where 用法：arr.Where(a =&gt; { return a &gt; 3; }) 说明：找到集合中满足指定条件的元素 OfType 用法：arr.OfType() 说明：根据指定类型，筛选集合中的元素 &lt;2&gt;投影 Select 用法：arr.Select&lt;int, string&gt;(a =&gt; a.ToString()); 说明：将集合中的每个元素投影的新集合中。上例中：新集合是一个IEnumerable的集合 SelectMany 用法：arr.SelectMany&lt;int, string&gt;(a =&gt; { return new List() { “a”, a.ToString() }; }); 说明：将序列的每个元素投影到一个序列中，最终把所有的序列合并 &lt;3&gt;还有很多查询操作符，请翻MSDN，以后有时间我将另起一篇文章把这些操作符写全。 2.查询表达式 （1）源起 上面我们已经提到，使用查询操作符表示的扩展方法来操作集合； 虽然已经很方便了，但在可读性和代码的语义来考虑，仍有不足； 于是就产生了查询表达式的写法。 虽然这很像SQL语句，但他们却有着本质的不同。 （2）用法 from v in arr where v &gt; 3 select v 这就是一个非常简单的查询表达式 （3）说明： 先看一段伪代码： from [type] id in source [join [type] id in source on expr equals expr [into subGroup]] [from [type] id in source | let id = expr | where condition] [orderby ordering,ordering,ordering…] select expr | group expr by key [into id query] &lt;1&gt;第一行的解释： type是可选的， id是集合中的一项， source是一个集合， 如果集合中的类型与type指定的类型不同则导致强制类型转化 &lt;2&gt;第二行的解释： 一个查询表达式中可以有0个或多个join子句， 这里的source可以是一个全新的集合，可以不等于第一句中的source expr可以是一个表达式 [into subGroup] subGroup是一个中间变量， 它继承自IGrouping，代表一个分组，也就是说“一对多”里的“多” 可以通过这个变量得到这一组包含的对象个数，以及这一组对象的键 比如： from c in db.Customers join o in db.Orders on c.CustomerID equals o.CustomerID into orders select new { c.ContactName, OrderCount = orders.Count() }; &lt;3&gt;第三行的解释： 一个查询表达式中可以有1个或多个from子句 一个查询表达式中可以有0个或多个let子句，let子句可以创建一个临时变量 比如： from u in users let number = Int32.Parse(u.Username.Substring(u.Username.Length - 1)) where u.ID &lt; 9 &amp;&amp; number % 2 == 0 select u 一个查询表达式中可以有0个或多个where子句，where子句可以指定查询条件 &lt;4&gt;第四行的解释： 一个查询表达式可以有0个或多个排序方式 每个排序方式以逗号分割 &lt;5&gt;第五行的解释： 一个查询表达式必须以select或者group by结束 select后跟要检索的内容 group by 是对检索的内容进行分组 比如： from p in db.Products group p by p.CategoryID into g select new { g.Key, NumProducts = g.Count()}; &lt;6&gt;第六行的解释： 最后一个into子句起到的作用是 将前面语句的结果作为后面语句操作的数据源 比如： from p in db.Employees select new { LastName = p.LastName, TitleOfCourtesy = p.TitleOfCourtesy } into EmployeesList orderby EmployeesList.TitleOfCourtesy ascending select EmployeesList;三：参考资料 《LINQ实战》 《深入理解C#》第二版 《CLR VIA C#》第三版 《C# 高级编程》第四版 还有很多网络上的文章，就不一一例举了 转自：https://www.cnblogs.com/liulun/archive/2013/02/26/2909985.html#3748094]]></content>
  </entry>
  <entry>
    <title><![CDATA[C#中Linq常用方法]]></title>
    <url>%2F2019%2F08%2F07%2FC-%E4%B8%ADLinq%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 Aggregate—自定义的聚合计算 All—检测序列中所有元素是否都满足指定的条件 Any—检测序列中是否存在满足指定条件的元素 Average—计算序列中元素的平均值 Cast—将序列中元素的类型转换成指定的类型(由TResult参数指定) Contact—将一个序列中的元素全部追加到另一个序列中，并构成一个新的序列。 Contains—检测序列中是否存在指定的元素。 Count—计算序列中元素的数量，或者计算序列中满足条件元素的数量。 DefaultIfEmpty—返回IEnumerable类型的序列。如果序列为空，则返回只包含一个元素(值为默认值或指定的值)的序列 Distinct—可以去掉数据源中重复的元素，并返回一个新序列。另外，他还可以指定一个比较器来比较两个元素是否相同。 Element—返回集合中指定索引处的元素。 ElementAtOrDefault—返回集合中指定索引处的元素。如果索引超出集合的范围，则返回默认值 Empty—返回IEnumerable类型的空序列 EqualAll/SequenceEqual—判断两个序列是否相等。 Except—可以计算两个集合的差集(由在一个集合中而不在另一个集合中的元素组成的集合) First—返回集合的第一个元素，或者返回集合中满足制定条件的第一个元素。 FirstOrDefault—返回集合的第一个元素，或者返回集合中满足制定条件的第一个元素。如果不存在满足该条件的元素，则返回默认元素。 GroupBy—对序列中的元素进行分组 GroupJoin—他产生分层数据结构，降低一个集合中的每一个元素与第二个集合中的一组相关元素进行匹配。在查询结果中，第一个集合中的元素都会出现在查询结果中。如果第一个集合中的元素在第二个集合中找到相关的元素，则使用被找到的元素，否则使用空 Intersect—可以计算两个集合的交集(元素即在第一个序列中，也在第二个序列中) Join—要求元素的连接关系必须同时满足被链接的两个数据源，和SQL语句中的inner join字句相似 Last—返回集合的最后一个元素，或者返回集合的满足指定条件的最后一个元素。 LastOrDefault—返回集合的最后一个元素，或者返回集合的满足指定条件的最后一个元素。如果出存在满足该条件的元素，则返回默认元素。 LongCount—计算序列中元素的数量，或者计算序列满足一定条件的元素的数量。一半计算大型集合中的元素的数量。 Max—计算序列中元素的最大值。 Min—计算序列中元素的最小值。 OfType—从序列中筛选指定类型的元素，并构成为一个序列。 OrderBy—根据关键字对序列中的元素升序。 OrderByDescending—根据关键字对序列中的元素降序。 Range—返回指定范围的数字序列。 Repeat—返回IEnumerable类型的包含一个重复值得序列。 Reverse—将序列中的元素的顺序进行反转。 Select—将数据源中的元素投影到新序列中，并指定元素的类型和表现形式。 SelectMany—可以将数据源中的元素投影到新序列中，并制定元素的类型和表达式。 Single—返回集合的唯一元素，或者返回集合的满足指定条件的唯一元素。 SingleOrDefault—返回集合的唯一元素，或者返回集合的满足指定条件的唯一元素。如果不存在满足该条件的元素，则返回默认元素。 Skip—跳过数据源(序列)中指定数量的元素，然后返回剩余的元素或序列。 SkipWhile—跳过数据源(序列)中满足指定条件的元素，然后返回剩余的元素或序列。 Sum—计算序列中元素的和。 Take—从数据源(序列)的开头开始提取指定数量的元素。然后返回有这些元素组成的序列。 TakeWhile—从数据源(序列)的开头开始提取满足指定条件的元素。然后返回有这些元素组成的序列。 ThenBy—根据次要关键字对序列中的元素按升序排序。 ThereByDescending—根据次要关键字对序列中的元素按降序排列。 ToArray—将IEnumerable类型的序列转换为T[]类型的数组。 ToDictionary—按照键值将序列中的元素放入一对一的字典序列(Dictionary&lt;TKey,TValue&gt;)中。 ToList—将IEnumerable类型的序列转换为List类型的序列。 ToLookup—按照键值将序列中的元素放入一对多的字典序列(Lookup&lt;TKey,TValue&gt;)中。 Union—可以计算两个集合的并集(由在一个集合中，或者在另外一个集合中的元素组成的集合) Where—处理由逻辑运算符(如逻辑”与”、逻辑”或”)组成的逻辑表达式，并从数据源中筛选数据。 这些方法大致有可以分成几类：投影操作Select SelectMany 链接操作 Join GroupJoin 筛选操作 Where 排序操作 OrderBy OrderByDescending ThereBy ThereByDescending Reverse 聚合操作 Max Min Count LongCount Sum Aggregate 集合操作 Distinct Except Intersect Union 元素操作 Element ElementAtOrDefault First FirstOrDefault Last LastOrDefault Single SingleOrDefault 数据类型转换操作 AsQueryable ： 可以将数据源转换成IQueryable或者IIIIIQueryable的集合序列。 AsEnumerable ： 可以将数据源转换成IEnumerable或者IEnumerable的集合序列。 Cast ： 将序列中元素的类型转换为指定类型。 OfType ：从序列中筛选一个指定类型的元素，并构成一个序列。 ToArray ： 将一个IEnumerable的序列转换成一个T[]类型的一个数组。 ToList ： 将一个IEnumerable的序列转换成一个List类型的一个序列。 ToDictionary ： 按照键值将序列中的元素放入到一对一的字典序列中。 ToLookup ：按照键值将序列中的元素放入到一对多的字典序列中。 限定符操作 All Any Contains 还有 Skip SkipWhile Take TakeWhile Contact SequenceEqual 例子（待补充）1.跳过前面多少条数据取余下的数据 1234var linqtest = (from r in db.Am_recProScheme where r.rpId &gt; 10 orderby r.rpId descending select r).Skip(10).Take(10); //取第11条到第20条数据]]></content>
  </entry>
  <entry>
    <title><![CDATA[C#中的委托]]></title>
    <url>%2F2019%2F08%2F05%2FC-%E4%B8%AD%E7%9A%84%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[请点击阅读全文浏览详细信息 C#中的委托 委托和事件在 .NET Framework 中的应用非常广泛，然而，较好地理解委托和事件对很多接触 C# 时间不长的人来说并不容易。它们就像是一道槛儿，过了这个槛的人，觉得真是太容易了，而没有过去的人每次见到委托和事件就觉得心里堵得慌，浑身不自在。本章中，我将由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.NET Framework 中的委托和事件、委托中方法异常和超时的处理、委托与异步编程、委托和事件对Observer 设计模式的意义，对它们的编译代码也做了讨论。 1.1 理解委托1.1.1 将方法作为方法的参数 我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语： 123456789public void GreetPeople(string name)&#123; EnglishGreeting(name);&#125; public void EnglishGreeting(string name)&#123; Console.WriteLine("Good Morning, " + name);&#125; 暂且不管这两个方法有没有什么实际意义。GreetPeople 用于向某人问好，当我们传递代表某人姓名的 name 参数，比如说“Liker”进去的时候，在这个方法中，将调用 EnglishGreeting 方法，再次传递 name 参数，EnglishGreeting 则用于向屏幕输出 “Good Morning, Liker”。 现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Good Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法： 1234public void ChineseGreeting(string name)&#123; Console.WriteLine("早上好, " + name);&#125; 这时候，GreetPeople 也需要改一改了，不然如何判断到底用哪个版本的 Greeting 问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据： 1234567891011121314151617public enum Language&#123; English, Chinese&#125; public void GreetPeople(string name, Language lang)&#123; switch (lang) &#123; case Language.English: EnglishGreeting(name); break; case Language.Chinese: ChineseGreeting(name); break; &#125;&#125; OK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和GreetPeople() 方法，以适应新的需求。 在考虑新的解决方案之前，我们先看看 GreetPeople 的方法签名： 1public void GreetPeople(string name, Language lang); 我们仅看 string name，在这里，string 是参数类型，name 是参数变量，当我们赋给 name 字符串“Liker”时，它就代表“Liker”这个值；当我们赋给它“李志中”时，它又代表着“李志中”这个值。然后，我们可以在方法体内对这个 name 进行其他操作。哎，这简直是废话么，刚学程序就知道了。 如果你再仔细想想，假如 GreetPeople() 方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 EnglishGreeting 的时候，它代表着 EnglsihGreeting() 这个方法；当我们给它赋值ChineseGreeting 的时候，它又代表着 ChineseGreeting() 法。我们将这个参数变量命名为 MakeGreeting，那么不是可以如同给 name 赋值时一样，在调用 GreetPeople()方法的时候，给这个MakeGreeting 参数也赋上值么(ChineseGreeting 或者EnglsihGreeting 等)？然后，我们在方法体内，也可以像使用别的参数一样使用MakeGreeting。但是，由于 MakeGreeting 代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：MakeGreeting(name); 好了，有了思路了，我们现在就来改改GreetPeople()方法，那么它应该是这个样子了： 1234public void GreetPeople(string name, *** MakeGreeting)&#123; MakeGreeting(name);&#125; 注意到 *** ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写 GreetPeople 方法，现在就出现了一个大问题：这个代表着方法的 MakeGreeting 参数应该是什么类型的？ 说明：这里已不再需要枚举了，因为在给MakeGreeting 赋值的时候动态地决定使用哪个方法，是 ChineseGreeting 还是 EnglishGreeting，而在这个两个方法内部，已经对使用“Good Morning”还是“早上好”作了区分。 聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看MakeGreeting 参数所能代表的 ChineseGreeting()和EnglishGreeting()方法的签名： 123public void EnglishGreeting(string name)public void ChineseGreeting(string name) 如同 name 可以接受 String 类型的“true”和“1”，但不能接受bool 类型的true 和int 类型的1 一样。MakeGreeting 的参数类型定义应该能够确定 MakeGreeting 可以代表的方法种类，再进一步讲，就是 MakeGreeting 可以代表的方法的参数类型和返回类型。 于是，委托出现了：它定义了 MakeGreeting 参数所能代表的方法的种类，也就是 MakeGreeting 参数的类型。 本例中委托的定义： 1public delegate void GreetingDelegate(string name); 与上面 EnglishGreeting() 方法的签名对比一下，除了加入了delegate 关键字以外，其余的是不是完全一样？现在，让我们再次改动GreetPeople()方法，如下所示： 12345public delegate void GreetingDelegate(string name);public void GreetPeople(string name, GreetingDelegate MakeGreeting)&#123; MakeGreeting(name);&#125; 如你所见，委托 GreetingDelegate 出现的位置与 string 相同，string 是一个类型，那么 GreetingDelegate 应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为 Delegate 是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码： 1234567891011121314151617181920212223242526public delegate void GreetingDelegate(string name); class Program&#123; private static void EnglishGreeting(string name) &#123; Console.WriteLine("Good Morning, " + name); &#125; private static void ChineseGreeting(string name) &#123; Console.WriteLine("早上好, " + name); &#125; private static void GreetPeople(string name, GreetingDelegate MakeGreeting) &#123; MakeGreeting(name); &#125; static void Main(string[] args) &#123; GreetPeople("Liker", EnglishGreeting); GreetPeople("李志中", ChineseGreeting); Console.ReadLine(); &#125;&#125; 我们现在对委托做一个总结：委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用If … Else(Switch)语句，同时使得程序具有更好的可扩展性。 1.1.2 将方法绑定到委托 看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在 GreetPeople() 方法中给 name 参数赋值，我可以像这样使用变量： 123456static void Main(string[] args)&#123; GreetPeople("Liker", EnglishGreeting); GreetPeople("李志中", ChineseGreeting); Console.ReadLine();&#125; 而既然委托 GreetingDelegate 和类型 string 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？ 123456789static void Main(string[] args)&#123; GreetingDelegate delegate1, delegate2; delegate1 = EnglishGreeting; delegate2 = ChineseGreeting; GreetPeople("Liker", delegate1); GreetPeople("李志中", delegate2); Console.ReadLine();&#125; 如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于 string 的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下： 12345678static void Main(string[] args)&#123; GreetingDelegate delegate1; delegate1 = EnglishGreeting; delegate1 += ChineseGreeting; GreetPeople("Liker", delegate1); Console.ReadLine();&#125; 实际上，我们可以也可以绕过GreetPeople 方法，通过委托来直接调用EnglishGreeting 和ChineseGreeting： 12345678static void Main(string[] args)&#123; GreetingDelegate delegate1; delegate1 = EnglishGreeting; delegate1 += ChineseGreeting; delegate1("Liker"); Console.ReadLine();&#125; 说明：这在本例中是没有问题的，但回头看下上面 GreetPeople() 的定义，在它之中可以做一些对于 EnglshihGreeting 和 ChineseGreeting 来说都需要进行的工作，为了简便我做了省略。 注意这里，第一次用的“=”，是赋值的语法；第二次，用的是“+=”，是绑定的语法。如果第一次就使用“+=”，将出现“使用了未赋值的局部变量”的编译错误。我们也可以使用下面的代码来这样简化这一过程： 12GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);delegate1 += ChineseGreeting; 既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”： 1234567891011static void Main(string[] args)&#123; GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting); delegate1 += ChineseGreeting; GreetPeople("Liker", delegate1); Console.WriteLine(); delegate1 -= EnglishGreeting; GreetPeople("李志中", delegate1); Console.ReadLine();&#125; 让我们再次对委托作个总结： 使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。 转自：https://www.cnblogs.com/hushzhang/p/5901052.html]]></content>
  </entry>
</search>
